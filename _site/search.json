[
  
  
    {
      "title": "Github",
      "tags": "Github",
      "desc": "Github - 2025년09월24일  tag : Github|",
      "content": "Github - 2025년09월24일  tag : Github|초기 설정이름과 이메일 설정git config --global user.name \"사용자이름\"git config --global user.email \"이메일\"모든 Git 설정 정보 한번에 보기git config --listLocal 환경에서 작업git initmkdir 디렉터리이름  # 디렉터리 생성cd 디렉터리이름     # 디렉터리로 이동git init          # Git 저장소 초기화git add, git commitvim 파일이름  # 파일 생성 및 편집 [ i : 입력모드, esc : 명령모드, :wq! : 저장 후 종료 ]cat 파일이름  # 파일 내용 확인git status   # 현재 상태 확인# 방법 1: 스테이징 + 커밋 분리git add .  # 새 파일은 이 명령어로 스테이징git commit -m \"커밋 메시지\"  # or git commit 입력 후 에디터에서 작성# 방법 2: 수정된 파일 자동 스테이징 + 커밋git commit -am \"커밋 메시지\"# 방법 3: 메시지 없이 (에디터에서 입력)git commit -agit branch, git checkoutgit branch            # 브랜치 목록 확인git branch 브랜치이름    # 새 브랜치 생성git checkout 브랜치이름  # 브랜치 전환git branch -d 브랜치이름   # 브랜치 삭제git mergegit checkout master         # 메인 브랜치로 전환git merge 브랜치이름        # 브랜치 병합git loggit log               # 커밋 로그 확인git log --oneline    # 한 줄 요약 로그 확인git log --graph      # 그래프 형태로 로그 확인.gitignore  참고 사이트 : gitignoretouch .gitignore # .gitignore 빈 파일 생성git log : 기록 보기git log              # 커밋 로그 확인git log --oneline    # 한 줄 요약 로그 확인git log --graph      # 브랜치 분기와 병합 내역을 아스키 그래프로 확인원격 저장소와 연동GitHub에 원격 저장소 생성git clone &lt;원격 저장소 URL&gt;  # 원격 저장소 복제원격 저장소 추가 및 연동git remote add &lt;원격 이름&gt; &lt;원격 저장소 URL&gt; # 로컬 저장소를 특정 원격 저장소와 연결git remote -v # 연결된 원격 저장소 확인로컬 커밋을 원격 저장소에 업로드# Ex## git push origin --all # 모든 브랜치를 원격 저장소에 업로드## git push origin master # master 브랜치를 원격 저장소에 업로드git push &lt;원격 이름&gt; &lt;브랜치 이름&gt; # 로컬 커밋을 원격 저장소에 업로드원격 저장소의 변경 사항 가져오기# Ex## git fetch origin # 원격 저장소의 변경 사항을 로컬로 가져오기## git pull origin master # 원격 저장소의 master 브랜치 변경 사항을 로컬로 가져오고 병합## git log -1 --stat # 가장 최근 커밋 로그 확인git fetch &lt;원격 이름&gt; # 원격 저장소의 변경 사항을 로컬로 가져오기git pull &lt;원격 이름&gt; &lt;브랜치 이름&gt; # 원격 저장소의 변경 사항을 로컬로 가져오고 병합Git 고급최근 커밋 수정하기 (amend)# Ex## git add README.md # README.md 파일을 스테이징## git commit -m \"Add README\" # 스테이징된 파일을 커밋## README.md 파일을 수정## git add README.md # 수정된 README.md 파일을 스테이징## git commit --amend -m \"Update README\" # 마지막 커밋을 수정하여 새로운 커밋 메시지로 변경git commit --amend    # 같은 브랜치 상에 있는 최종 커밋을 취소하고 새로운 내용을 추가하거나 설명을 덧붙인 커밋을 할 수 있다.안전하게 커밋 되돌리는 방법 (revert)  이전 커밋을 남겨두는 방법git revert &lt;커밋 해시&gt;            # 이미 푸시된 커밋을 취소하는 방법이전 작업 결과를 저장한 상태로 되돌리기 ( reset )  어떤 특정 커밋을 사용하지 않게 되어 다시 되돌릴 때 사용git revert와 다르게 커밋 기록이 남지 않는다.  git reset 명령어의 모드            모드      의미      HEAD 위치      인덱스      저장소 디렉터리                  hard      완전히 되돌림      변경      변경      변경              mixed      인덱스의 상태를 되돌림. 모드를 지정하지 않았을 때의 기본값      변경      변경      유지              soft      커밋만 되돌림      변경      유지      유지        git reset 명령어 옵션            옵션      의미                  ^혹은 ~      ~은 커밋 내역 하나를 의미합니다. 표시한 수 만큼 커밋을 되돌립니다.              ORIG_HEAD      git reset 명령을 실행했을 때 지운 커밋 내역을 보관합니다. 해당 명령을 통해 git reset 명령으로 지운 커밋을 되돌릴 수 있습니다.      git reset             # 어떤 커밋을 버리고 이전의 특정 버전으로 다시 되돌릴 때 사용특정 파일을 최종 커밋 상태로 되돌리기 (checkout)# Ex## git add README.md # README.md 파일을 스테이징 -- 1## git checkout HEAD -- README.md # README.md 파일을 마지막 커밋 상태로 되돌림## --&gt; 1번에서 스테이징한 README.md 파일이 마지막 커밋 상태로 되돌아감git checkout HEAD -- filenamegit rebase : 브랜치 이력 정리하기            옵션      의미                  –continue      충돌이 해결된 후 rebase를 계속 진행              –abort      rebase를 중단하고 이전 상태로 되돌림              –skip      충돌이 발생한 커밋을 건너뛰고 rebase를 계속 진행      # Ex## vi testfile.txt # testfile.txt 파일 생성 및 편집## git add testfile.txt # testfile.txt 파일을 스테이징## git commit -m \"Add testfile.txt in master\" # master 브랜치에 커밋 ## git branch hotfix1 # hotfix1 브랜치 생성## git checkout hotfix1 # hotfix1 브랜치로 전환## vi testfile.txt # testfile.txt 파일 생성 및 편집## git add testfile.txt # testfile.txt 파일을 스테이징## git commit -m \"Add testfile.txt in hotfix1\" # hotfix1 브랜치에 커밋## git rebase master # error 발생 (충돌)## vi testfile.txt # 충돌 해결## git add testfile.txt # 수정된 testfile.txt 파일을 스테이징## git rebase --continue # rebase 계속 진행## git checkout master # master 브랜치로 전환## git merge hotfix1 --no-ff # fast-forward를 방지하고 병합 커밋 생성git rebase            # git merge처럼 병합할 때 사용합니다. 하지만 브랜치가 많을 경우 브랜치 이력을 확인하면서 병합합니다.git rebase -i HEAD~~        # 서로 다른 두 개의 커밋 내역을 합칩니다. | ~ : 커밋 내역 하나를 의미합니다.",
      "url": "/2025/09/24/GitHub.html"
    },
  
    {
      "title": "Anaconda",
      "tags": "Anaconda",
      "desc": "Anaconda - 2025년09월20일  tag : Anaconda|",
      "content": "Anaconda - 2025년09월20일  tag : Anaconda|Anaconda 설치 후 환경 변수 설정  환경 변수 진입  Path 클릭  경로 추가        anaconda3    anaconda3\\Library    anaconda3\\Scripts      ",
      "url": "/2025/09/20/anaconda_settings.html"
    },
  
    {
      "title": "Runpod",
      "tags": "RUNPOD",
      "desc": "Runpod - 2025년07월25일  tag : RUNPOD|",
      "content": "Runpod - 2025년07월25일  tag : RUNPOD|ERRORrunpod에 vscode로 접속 시install terminal quit with output: 프로세스에서 없는 파이프에 쓰려고 했습니다.  해결책 : C:\\Users\\{사용자이름}\\.ssh 접속 후 known_hosts 파일 열어서 전부 삭제OthersRUNPOD files → Local Downloads# powershellscp -r -P {포트번호} `  -i \"C:\\Users\\YourUser\\.ssh\\id_ed25519\" `  \"root@{서버주소}:{원격폴더경로}\" `  \"{로컬 저장 경로}\"",
      "url": "/2025/07/25/RUNPOD.html"
    },
  
    {
      "title": "Python",
      "tags": "PYTHON",
      "desc": "Python - 2025년07월25일  tag : PYTHON|",
      "content": "Python - 2025년07월25일  tag : PYTHON|가상환경 설정LocalWindow - Command Prompt - anaconda# 가상환경 생성# conda create -n {가상환경 폴더 명} python={파이썬 버젼 명}## Ex. python 3.11 버젼, venv 폴더 명으로 가상환경 생성 conda create -n venv python=3.11## 가상환경 진입conda activate venv## 가상환경 종료conda deactivateERRORRAGReranker  코드from langchain_community.cross_encoders import HuggingFaceCrossEncoderhf_reranker = HuggingFaceCrossEncoder(    model_name=\"BAAI/bge-reranker-v2-m3\")  error 문구Error rendering output item using 'jupyter-ipywidget-renderer'Cannot read properties of undefined (reading 'ipywidgetsKernel')  해결 방법pip install ipywidgets --upgradejupyter nbextension enable --py widgetsnbextension --sys-prefixjupyter nbextension install --py widgetsnbextension --sys-prefixOthers라이브러리 관리  방법1pip freeze &gt; requirements.txtpip install -r requirements.txt  방법2pip install pipreqspipreqs ./ --force# 폴더 내에서 환경이 존재하는 경우pipreqs . --force --ignore \"{가상환경}/Lib\"  방법3# 새로운 라이브러리를 설치 후 requirements.txt 에 적용할 때# Ex. cohere 설치했을경우pip freeze | grep cohere",
      "url": "/2025/07/25/PYTHON.html"
    },
  
    {
      "title": "Jekyll Blog",
      "tags": "Jekyll_Blog",
      "desc": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|",
      "content": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|ERRORJekyll Build Error  error 코드Invalid date '&lt;%= Time.now.strftime('%Y-%m-%d %H:%M:%S %z') %&gt;': Document '.../0000-00-00-welcome-to-jekyll.markdown.erb' does not have a valid date in the YAML front matter.      해결 방법          GitHub Actions 환경에서 이 에러가 발생한 것이라면, 루트 디렉토리에 있는 _posts/가 아닌 vendor/ 내부에 있는 템플릿 파일이 빌드 과정에 포함되지 않도록 설정해야 함.        # _config.yml 에 아래 작성exclude:- vendor      ",
      "url": "/2025/07/25/Jekyll_Blog.html"
    },
  
    {
      "title": "Github - 002",
      "tags": "Github",
      "desc": "Github - 002 - 2024년12월16일  tag : Github|",
      "content": "Github - 002 - 2024년12월16일  tag : Github|Merge Conflict 해결방법  Solve Merge Conflict [ 일반적인 상황에서 사용 ]-&gt; Merge 상황에서 해결  Solve Merge Conflict [ 특수한 상황에서 사용 ]-&gt; rebase 방법으로 해결Branch Models  git flow          가장 전통적이고 많이쓰이는 모델각 단계가 명확히 구분되어 배포주기가 주기적인 서비스에 유리. 하지만 복잡        github flow          브랜치 모델의 단순화.CI 의존성이 높고, pull request가 없으면 실수에 대처가 힘듬      $ git branch feature/{새로운 branch 이름}$ git switch feature/{새로운 branch 이름}$ vi {파일명.확장자} # 여기서 main branch 와 다르게 수정$ git add {파일명.확장자}$ git commit$ git push -u origin feature/refactor-fb # u : 새로운 branch에서 push 할 때 한번만 사용하면 OK# 깃허브 리퍼지스토리에 들어가기# Pull requests에 접속 -&gt; Create pull request# feature/{새로운 branch 이름} 선택# Create pull request 선택 후 title, description 잘 짓기 (+ Assignees(담당자) 선택) -&gt; Create pull request# Merge pull request 선택 -&gt; Confirm merge# 작업이 다 끝났으므로# 왼쪽 위 main 클릭 -&gt; View all branches 클릭 -&gt; feature/{새로운 branch 이름} 삭제# git bash에 돌아와서# feature/{새로운 branch 이름} 삭제$ git branch -D feature/{새로운 branch 이름}# github cloud에 있는 최종 데이터를 로컬에 받기$ git pull origin main  gitlab flow          deploy, issue에 대응을 하기 쉽도록 한 모델      stash  작업중인 변경사항 잠시 미뤄두기 [ 새로운 branch 에서 사용 ]  $ git stash$ git stash list     # stash 목록 보기$ git stash pop {번호} # stash 다시 불러오기 {번호}는 특정한 stash 불러올 때만  undo  변경사항 취소하기  $ git restore {파일명.파일확장자}  Unstaging  Stage의 변경사항(blob) Working Directory로 내리기  $ git add {파일명.파일확장자}$ git reset HEAD {파일명.파일확장자}    # HEAD : 마지막의, 최신의  Edit commit message  직전 commit message 수정하기git add -&gt; commit -&gt;  $ git commit --amend  Revert commit  잘못을 인정하고 특정시점으로 되돌리기git add -&gt; commit 인 상황에서  $ git revert --no-commit HEAD~{되돌리고 싶은 commit 숫자}..$ git status   # 삭제 이력 나와있음$ git commit    # 왜 사용했는지 이유를 적어야 함  Issue  github 프로젝트의 다양한 이슈를 관리하기 위한 기능할 일, 버그, 질문 등을 관리하기 위함Label, 상태 관리 등의 업데이트가 잘 이루어져야 원할한 작업 가능template 존재[ 깃허브 repotory -&gt; settings -&gt; issue template ]Issue Labels      Issue의 상태와 종류, 긴급도 등을 표시하기 위함Milestone : 작성된 Issue가 프로젝트의 어떤 주기에서 해결되어야 하는지를 표기Milestone 작성을 통해 해당 Sprint의 달성률과 남은 Issue 파악이 쉬워짐  Projects  github에서 repo issue 기반의 task managementScrum board와 table의 방식 존재.팀의 Admin만 관리 가능(관리자가 관리하는 것이 맞음!!)commit, pull request 등을 통해 자동으로 움직이도록 관리할 수 있음Wiki  repository에서 README.md 에서 더 자세히 설명할 부분이 있을 경우 작성따로 사이트를 만들지 않더라도 해당 프로젝트에 대한 FAQ, Docs 처리 가능프로젝트 중 문서화가 필요한 모든 것들을 담아놓는 공간Daily Scrum, Sprint Retrospection(Liked, Learned, Lacked), Code Convention, Technical Issuespull request [깃허브 상에서]  명령어 지원close, resolve, fix(복수형, 과거형)ex. resolve #1팀 Project REMOTE 과정[main branch 에서 실행]$ git remote -v    # remote 확인보기$ git remote add upstream {팀 repository 주소}   # 관습적으로 팀 이름은 upstream 이라고 부름$ git fetch upstream main   # FETCH_HEAD 라는 공간에 쌓임$ git merge FETCH_HEAD$ git push origin main해야할 것!  직접 프로젝트를 생성하고 협업하는 과정을 처음부터 끝까지 해보기!",
      "url": "/2024/12/16/Github-002.html"
    },
  
    {
      "title": "Github - 001",
      "tags": "Github",
      "desc": "Github - 001 - 2024년12월14일  tag : Github|",
      "content": "Github - 001 - 2024년12월14일  tag : Github|Github  git bash 에서 아래 나오는 코드 실행하기환경설정  정보 확인하기$ git config --list  위 출력에서 없는 것을 확인한 후 추가$ git config --global uesr.name \"{username}\"$ git config --global user.email \"{emaliaddr}\"$ git config --global core.editor \"vim\"$ git config --global core.pager \"cat\"  Tip  만약 core.editor 값이 vim, notepad 두 개가 있을 경우  $ vi ~/.gitconfig    위 명령어 입력 후 notepad부분을 지우고 저장 후 다시 $ git config –list 로 확인하기깃허브 생성  단계          깃허브 접속      create repository -&gt; public 선택, Lisence : MIT 로 선택      주소 복사 후[HTML] git bash 에서 다음 명령어 입력        git clone \"주소\"                    깃허브 상태 확인 후 commit 까지$ git status # 자주 확인해주는 것이 좋다.$ git add {파일명.확장자}$ git commit$ git remote      # origin$ git remote -v$ git push origin main # origin[git remote으로 확인한 값]에 main branch로 올린다.  비밀 키 받기          오른쪽 맨 위 프로필 아이콘 클릭 -&gt; Settings 클릭      왼쪽 사이드 바에서 Developer Settings 클릭      왼쪽 사이드 바에서 Personal access tokens 아래에 있는 Tokens(Classic) 클릭      오른쪽 위에 Generate new token 선택 후 Generate new token(classic) 선택      pre-commit  commit 수행 전 체크해야 할 것들을 자동 수행하도록 도와주는 도구참고 사이트$ pip install pre-commit (or $ pip3 install pre-commit) # 설치$ pre-commit --version # 잘 설치되었는지 확인$ pre-commit sample-config &gt; .pre-commit-config.yaml # .pre-commit-config.yaml 파일 생성$ cat .pre-commit-config.yaml # 내용보기  사용방법          commit 하기 전에 사용      $ pre-commit run$ pre-commit run -a # 이것을 주로 사용하는 것 같다.[개인적인 의견]            Branch  분기점을 생성하여 독립적으로 코드를 변경할 수 있도록 도아주는 모델  branch 확인하기$ git branch$ git branch -r$ git branch -a  branch 생성$ git branch {branch 이름} # branch 생성$ git switch {branch 이름} # branch 전환... { 여기서 branch에서 작업 add -&gt; commit }$ git switch main # main branch 로 전환$ git merge {branch 이름} # main이 아닌 다른 branch 에서 작업한 것을 합치기$ git branch -D {branch 이름} # branch 삭제그 외  보기좋은 로그 출력하기    $ git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"    commit 메세지 작성하는 방법          참고사이트        github repository 생성 사이트          참고사이트        gitignore 파일 만들기          참고사이트1참고사이트2        github에서 jupyter notebook 변경사항을 보고 싶을 때          오른쪽 위 프로필 사진 클릭 -&gt; Feature preview 클릭 -&gt; Rich Jupyter Notebook Diffs 활성화        git 을 쓰면서 습관들이면 안되는 것    &gt; $ git add . : 현재 디렉토리 하위의 모든 파일을 staging할 때 사용.&gt; but, 현재 commit단위에 들어가면 안되는 파일까지 휩쓸릴 수 있으므로 습관적으로 사용하면 안됩니다.&gt; $ git commit -m \"Message\" : 쉘에서 바로 메시지를 쓰면서 커밋할 때 사용.&gt; but, revert commit, merge commit 등의 상황에서 메시지를 덮어쓸 우려가 있으므로 습관적으로 사용하면 안됩니다.&gt; 저장소 안에 저장소 clone 하기 : 프로젝트 단위는 항상 독립적으로 존재해야 합니다.&gt; 의미없는 commit message 남기기(ex. a, 1, ..) : commit message는 제목만으로 해당 작업단위에 대한 설명이 가능해야 나중에 고생하지 않습니다.&gt; Conventional commit 잘 지키기!!      ",
      "url": "/2024/12/14/Github-001.html"
    },
  
    {
      "title": "A/B TEST",
      "tags": "AB_TEST",
      "desc": "A/B TEST - 2024년10월28일  tag : AB_TEST|",
      "content": "A/B TEST - 2024년10월28일  tag : AB_TEST|정의  A/B TEST : 두 가지 이상의 버전을 비교하여 어떤 것이 더 나은 성과를 내는지 판단하는 실험 방법A/B TEST 하는 이유  상관관계로부터 인과관계[ 정확히 말하면 인과관계일 가능성이 높은 것 ]를 찾아내기 위함이다.A/B TEST 절차  목표 설정 : 테스트의 목적과 개선하고자 하는 지표를 명확히 정의  가설 수립 : 어떤 변경이 목표 달성에 도움이 될 것인지 가설을 세우기  테스트 설계 : A안(기존안)과 B안(변경안)을 구체화하기 -&gt; 테스트 기간, 샘플 크기, 분석 방법 등을 결정  테스트 실행 : 사용자를 무작위로 A그룹과 B그룹으로 나누고, 각 그룹에 해당 버전을 노출시키기  데이터 수집 : 설정한 기간 동안 각 그룹의 성과 데이터를 수집  결과 분석 : 통계적 유의성을 검증하여 A안과 B안의 성과 차이를 분석  결론 도출 및 적용 : 분석 결과를 바탕으로 더 나은 버전을 선택 -&gt; 선택한 버전을 전체 사용자에게 적용  지속적 개선 : 테스트 결과를 바탕으로 새로운 가설을 수립하고 추가 테스트를 진행주의해야 할 점      Correlation does not imply causation : 상관관계는 인과관계를 뜻하지 않는다.    - A/B TEST를 통해 인과관계를 알아내려면 두 집단을 나눠야 한다 =&gt; 임의적 할당(random assignment)&gt; EX ] 남성 VS 여성, 이번주 사용자 VS 다음주 사용자- A/B TEST를 통해 찾아낸 결과가 범용성을 지니려면 애초에 실험에 참가한 집단이 모집단을 대표할 수 있어야 한다.            테스트를 많이/자주하면 단기적으로 손해가 발생할 수 있다.    &gt; A/B 테스트 결과는 해당 테스트에만 국한되며, 새로운 테스트마다 새로운 기준선이 필요&gt; 이는 끊임없는 테스트 사이클로 이어질 수 있으며, 장기적인 전략 수립을 방해할 수 있다.            A/B 테스팅의 결과는 계절 변화나 취향 변화 등 시간의 흐름에 따라 바뀔 수 있다.    &gt; EX ] 작년 겨울에 진행한 테스트는 언제까지 유효할까?            사용자 행동의 완전한 이해 부족    &gt; A/B 테스트는 어떤 버전이 더 나은 성과를 보이는지는 알려주지만, 왜 그런지에 대한 깊이 있는 이해를 제공하지 않는다.        참고 사이트",
      "url": "/2024/10/28/AB_test.html"
    }
  
]

[
  
  
    {
      "title": "SQL",
      "tags": "SQL",
      "desc": "SQL - 2025년12월13일  tag : SQL|",
      "content": "SQL - 2025년12월13일  tag : SQL|SQLSQL Injection개념 및 정의SQL Injection은 악의적인 사용자가 SQL 쿼리문에 비정상적인 SQL 코드를 삽입하여 데이터베이스를 공격하는 보안 취약점입니다. 웹 애플리케이션의 입력 필드나 URL 매개변수 등을 통해 악의적인 SQL 명령어를 주입하고, 이를 데이터베이스에서 실행하게 함으로써 권한 없이 데이터에 접근하거나 조작할 수 있습니다.문제점  데이터 유출: 데이터베이스의 민감한 정보(사용자 계정, 개인정보 등)가 노출될 수 있습니다.  데이터 손상: 악의적으로 데이터를 삭제하거나 수정할 수 있습니다.  인증 우회: 로그인 인증을 우회하여 관리자 권한으로 접근할 수 있습니다.  시스템 제어: 데이터베이스 서버에 대한 제어권을 얻을 수 있습니다.SQL Injection 예시:-- 정상적인 쿼리SELECT * FROM users WHERE id = 'user_input' AND password = 'password_input'-- 악의적인 입력 (id: ' OR '1'='1)SELECT * FROM users WHERE id = '' OR '1'='1' AND password = 'password_input'-- 결과: 모든 사용자 정보가 반환됨예방 방법  Prepared Statement 사용          쿼리의 구조와 데이터를 분리하여 입력값을 매개변수로 처리합니다.        -- 안전한 방법 (Prepared Statement)PREPARE stmt FROM 'SELECT * FROM users WHERE id = ? AND password = ?'EXECUTE stmt USING user_input, password_input                      입력값 검증 및 필터링          사용자 입력값의 길이, 형식, 타입을 검증합니다.      특수문자(‘ “ ; – /* */ 등)를 제거하거나 이스케이프 처리합니다.        이스케이프 처리          쿼리에 포함되는 모든 문자열을 적절히 이스케이프 처리합니다.        # Python 예시escaped_input = input_value.replace(\"'\", \"''\")                      최소 권한 원칙 (Least Privilege)          데이터베이스 계정에 필요한 최소한의 권한만 부여합니다.      읽기 전용 계정, 특정 테이블만 접근 가능한 계정 등으로 제한합니다.        에러 메시지 제한          데이터베이스 에러 메시지를 사용자에게 노출하지 않습니다.      일반적인 에러 메시지만 반환하도록 처리합니다.        웹 애플리케이션 방화벽 (WAF)          SQL Injection 패턴을 탐지하고 차단하는 WAF 솔루션을 사용합니다.        정기적인 보안 감시 및 로깅          의심스러운 SQL 쿼리를 모니터링하고 로깅합니다.      정기적인 보안 감사를 수행합니다.      ",
      "url": "/2025/12/13/SQL.html"
    },
  
    {
      "title": "Github",
      "tags": "Github",
      "desc": "Github - 2025년12월13일  tag : Github|",
      "content": "Github - 2025년12월13일  tag : Github|Github초기 설정환경설정정보 확인하기git config --list이름과 이메일 설정git config --global user.name \"사용자이름\"git config --global user.email \"이메일주소\"git config --global core.editor \"vim\"git config --global core.pager \"cat\"Tip만약 core.editor 값이 vim, notepad 두 개가 있을 경우:vi ~/.gitconfig위 명령어 입력 후 notepad 부분을 지우고 저장 후 다시 git config --list로 확인하기Local 환경에서 작업git initmkdir 디렉터리이름  # 디렉터리 생성cd 디렉터리이름     # 디렉터리로 이동git init          # Git 저장소 초기화git add, git commitvim 파일이름  # 파일 생성 및 편집 [ i : 입력모드, esc : 명령모드, :wq! : 저장 후 종료 ]cat 파일이름  # 파일 내용 확인git status   # 현재 상태 확인 (자주 확인해주는 것이 좋다)커밋하기# 방법 1: 스테이징 + 커밋 분리git add 파일명.확장자  # 특정 파일 스테이징git add .             # 모든 변경사항 스테이징git commit            # 에디터에서 커밋 메시지 작성git commit -m \"커밋 메시지\"  # 인라인으로 커밋 메시지 작성# 방법 2: 수정된 파일 자동 스테이징 + 커밋git commit -am \"커밋 메시지\"# 방법 3: 메시지 없이 (에디터에서 입력)git commit -agit branch, git checkoutgit branch              # 브랜치 목록 확인git branch -r           # 원격 브랜치 목록 확인git branch -a           # 모든 브랜치 목록 확인git branch 브랜치이름     # 새 브랜치 생성git checkout 브랜치이름   # 브랜치 전환git switch 브랜치이름     # 브랜치 전환 (최신 방식)git branch -d 브랜치이름  # 브랜치 삭제git branch -D 브랜치이름  # 브랜치 강제 삭제git mergegit checkout master         # 메인 브랜치로 전환git merge 브랜치이름         # 브랜치 병합git merge 브랜치이름 --no-ff # fast-forward를 방지하고 병합 커밋 생성git loggit log               # 커밋 로그 확인git log --oneline     # 한 줄 요약 로그 확인git log --graph       # 그래프 형태로 로그 확인git log -1 --stat     # 가장 최근 커밋 로그 확인보기 좋은 로그 출력 설정git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\".gitignore특정 파일이나 디렉터리를 Git에서 추적하지 않도록 설정touch .gitignore  # .gitignore 빈 파일 생성참고 사이트  gitignore.io  gitignore API 예시원격 저장소 연동깃허브 저장소 생성 및 Clone저장소 생성 단계:  깃허브 접속  Create repository → Public 선택, License: MIT 선택  주소 복사 후 Git Bash에서 다음 명령어 입력:git clone \"저장소 주소\"  # 원격 저장소 복제원격 저장소 추가 및 연동git remote                              # 원격 저장소 확인 (origin)git remote -v                           # 연결된 원격 저장소 상세 확인git remote add origin 원격저장소URL      # 로컬 저장소를 원격 저장소와 연결Push &amp; Pull로컬 커밋을 원격 저장소에 업로드git push origin main              # origin의 main 브랜치로 업로드git push origin --all             # 모든 브랜치를 원격 저장소에 업로드git push -u origin feature/이름   # 새로운 브랜치 최초 push (-u는 한 번만 사용)원격 저장소의 변경 사항 가져오기git fetch origin              # 원격 저장소의 변경 사항을 로컬로 가져오기git pull origin main          # 원격 저장소의 main 브랜치 변경 사항을 가져오고 병합git merge FETCH_HEAD          # fetch한 내용 병합GitHub Personal Access Token비밀 키 받기:  오른쪽 맨 위 프로필 아이콘 클릭 → Settings 클릭  왼쪽 사이드 바에서 Developer Settings 클릭  Personal access tokens → Tokens (Classic) 클릭  Generate new token → Generate new token (classic) 선택Git 고급 기능stash작업 중인 변경사항을 임시로 저장git stash              # 현재 변경사항 임시 저장git stash list         # stash 목록 보기git stash pop          # 가장 최근 stash 불러오기git stash pop stash@{번호}  # 특정 stash 불러오기undo &amp; restore변경사항 취소하기git restore 파일명.파일확장자  # 파일을 최종 커밋 상태로 되돌리기git checkout HEAD -- 파일명    # 파일을 마지막 커밋 상태로 되돌림UnstagingStage의 변경사항을 Working Directory로 내리기git add 파일명.파일확장자git reset HEAD 파일명.파일확장자  # HEAD: 마지막의, 최신의커밋 수정하기 (amend)최근 커밋 메시지 수정하기git commit --amend                # 에디터에서 메시지 수정git commit --amend -m \"새 메시지\"  # 인라인으로 메시지 수정같은 브랜치 상에 있는 최종 커밋을 취소하고 새로운 내용을 추가하거나 설명을 덧붙인 커밋을 할 수 있습니다.Revert commit잘못을 인정하고 특정 시점으로 되돌리기 (이미 push된 커밋을 안전하게 취소)git revert --no-commit HEAD~되돌리고싶은커밋숫자..git status    # 삭제 이력 확인git commit    # 왜 revert했는지 이유를 적어야 함또는git revert 커밋해시  # 특정 커밋을 취소하는 새로운 커밋 생성Reset어떤 특정 커밋을 사용하지 않게 되어 다시 되돌릴 때 사용git revert와 다르게 커밋 기록이 남지 않습니다.git reset 모드:            모드      의미      HEAD 위치      인덱스      작업 디렉터리                  hard      완전히 되돌림      변경      변경      변경              mixed      인덱스의 상태를 되돌림 (기본값)      변경      변경      유지              soft      커밋만 되돌림      변경      유지      유지      git reset 옵션:            옵션      의미                  ^ 혹은 ~      ~은 커밋 내역 하나를 의미. 표시한 수만큼 커밋을 되돌림              ORIG_HEAD      git reset 명령으로 지운 커밋 내역을 보관. 이를 통해 reset한 커밋을 되돌릴 수 있음      git rebase브랜치 이력을 정리하고 깔끔하게 병합기본 rebase:git checkout hotfix1git rebase master     # master를 기준으로 hotfix1을 재배치# 충돌 발생 시:# 1. 충돌 해결# 2. git add 파일명# 3. git rebase --continuegit checkout mastergit merge hotfix1 --no-ff  # master로 병합rebase 옵션:            옵션      의미                  –continue      충돌이 해결된 후 rebase를 계속 진행              –abort      rebase를 중단하고 이전 상태로 되돌림              –skip      충돌이 발생한 커밋을 건너뛰고 rebase를 계속 진행      인터랙티브 rebase (커밋 합치기):git rebase -i HEAD~~  # 서로 다른 두 개의 커밋 내역을 합침 (~ : 커밋 내역 하나)Merge Conflict 해결1. 일반적인 상황 (Merge)Merge 상황에서 충돌 해결2. 특수한 상황 (Rebase)rebase 방법으로 충돌 해결Branch Modelsgit flow  가장 전통적이고 많이 쓰이는 모델  각 단계가 명확히 구분되어 배포 주기가 주기적인 서비스에 유리  단점: 복잡함github flow  브랜치 모델의 단순화  CI 의존성이 높고, pull request가 없으면 실수에 대처가 힘듦GitHub Flow 작업 순서:# 1. 새 브랜치 생성 및 전환git branch feature/기능이름git switch feature/기능이름# 2. 작업 및 커밋vi 파일명.확장자  # main branch와 다르게 수정git add 파일명.확장자git commit# 3. 원격에 pushgit push -u origin feature/기능이름  # -u는 한 번만# 4. GitHub에서 Pull Request 생성# - Pull requests → Create pull request# - feature/기능이름 선택# - Title, description 작성 + Assignees(담당자) 선택# - Create pull request → Merge pull request → Confirm merge# 5. 브랜치 삭제 (GitHub 웹에서)# - main 클릭 → View all branches → feature/기능이름 삭제# 6. 로컬 브랜치 삭제git branch -D feature/기능이름# 7. 최종 데이터 pullgit pull origin maingitlab flowDeploy, issue에 대응하기 쉽도록 한 모델GitHub 협업 도구pre-commitcommit 수행 전 체크해야 할 것들을 자동 수행하도록 도와주는 도구설치 및 설정:pip install pre-commit              # 설치pre-commit --version                # 설치 확인pre-commit sample-config &gt; .pre-commit-config.yaml  # 설정 파일 생성cat .pre-commit-config.yaml         # 내용 보기사용 방법 (commit 하기 전):pre-commit run      # 스테이징된 파일 체크pre-commit run -a   # 모든 파일 체크 (주로 사용)참고 사이트: pre-commit.comIssueGitHub 프로젝트의 다양한 이슈를 관리하기 위한 기능  용도: 할 일, 버그, 질문 등을 관리  중요: Label, 상태 관리 등의 업데이트가 잘 이루어져야 원활한 작업 가능  Template: GitHub repository → Settings → Issue template에서 설정  Issue Labels: 상태와 종류, 긴급도 등을 표시 (참고)  Milestone: Issue가 프로젝트의 어떤 주기에서 해결되어야 하는지 표기. Sprint의 달성률과 남은 Issue 파악이 쉬워짐ProjectsGitHub에서 repository issue 기반의 task management  Scrum board와 table 방식 존재  팀의 Admin만 관리 가능  commit, pull request 등을 통해 자동으로 움직이도록 관리 가능WikiRepository에서 README.md보다 더 자세한 설명이 필요할 때 작성  별도 사이트 없이도 FAQ, Docs 처리 가능  프로젝트 중 문서화가 필요한 모든 것들을 담아놓는 공간  포함 내용: Daily Scrum, Sprint Retrospection (Liked, Learned, Lacked), Code Convention, Technical IssuesPull Request명령어 지원:  close, resolve, fix (복수형, 과거형)  예: resolve #1팀 프로젝트 협업팀 Project REMOTE 과정 (main branch에서 실행)git remote -v                              # remote 확인git remote add upstream 팀리포지토리주소     # 관습적으로 팀 이름은 upstreamgit fetch upstream main                    # FETCH_HEAD 공간에 쌓임git merge FETCH_HEADgit push origin main커밋 메시지 작성 규칙Conventional Commits 지키기!참고 사이트: conventionalcommits.org유용한 리소스      GitHub Repository 생성 사이트gh-profile-readme-generator    gitignore 파일 만들기          gitignore.io      API 예시        GitHub에서 Jupyter Notebook 변경사항 보기오른쪽 위 프로필 사진 클릭 → Feature preview → Rich Jupyter Notebook Diffs 활성화Git 사용 시 주의사항습관들이면 안 되는 것들# ❌ git add .# 현재 디렉토리 하위의 모든 파일을 staging할 때 사용# 문제: 현재 commit 단위에 들어가면 안 되는 파일까지 휩쓸릴 수 있음# ❌ git commit -m \"Message\"# 셸에서 바로 메시지를 쓰면서 커밋# 문제: revert commit, merge commit 등의 상황에서 메시지를 덮어쓸 우려# ❌ 저장소 안에 저장소 clone 하기# 프로젝트 단위는 항상 독립적으로 존재해야 함# ❌ 의미없는 commit message 남기기 (예: a, 1, ..)# commit message는 제목만으로 해당 작업 단위에 대한 설명이 가능해야 함반드시 지켜야 할 것  Conventional Commit 잘 지키기!  의미 있는 commit 단위로 작업하기  커밋 메시지는 명확하고 구체적으로 작성하기실습 과제직접 프로젝트를 생성하고 협업하는 과정을 처음부터 끝까지 해보기!",
      "url": "/2025/12/13/Github.html"
    },
  
    {
      "title": "Anaconda",
      "tags": "Anaconda",
      "desc": "Anaconda - 2025년09월20일  tag : Anaconda|",
      "content": "Anaconda - 2025년09월20일  tag : Anaconda|Anaconda 설치 후 환경 변수 설정  환경 변수 진입  Path 클릭  경로 추가        anaconda3    anaconda3\\Library    anaconda3\\Scripts      ",
      "url": "/2025/09/20/anaconda_settings.html"
    },
  
    {
      "title": "Runpod",
      "tags": "RUNPOD",
      "desc": "Runpod - 2025년07월25일  tag : RUNPOD|",
      "content": "Runpod - 2025년07월25일  tag : RUNPOD|ERRORrunpod에 vscode로 접속 시install terminal quit with output: 프로세스에서 없는 파이프에 쓰려고 했습니다.  해결책 : C:\\Users\\{사용자이름}\\.ssh 접속 후 known_hosts 파일 열어서 전부 삭제OthersRUNPOD files → Local Downloads# powershellscp -r -P {포트번호} `  -i \"C:\\Users\\YourUser\\.ssh\\id_ed25519\" `  \"root@{서버주소}:{원격폴더경로}\" `  \"{로컬 저장 경로}\"",
      "url": "/2025/07/25/RUNPOD.html"
    },
  
    {
      "title": "Python",
      "tags": "PYTHON",
      "desc": "Python - 2025년07월25일  tag : PYTHON|",
      "content": "Python - 2025년07월25일  tag : PYTHON|가상환경 설정LocalWindow - Command Prompt - anaconda# 가상환경 생성# conda create -n {가상환경 폴더 명} python={파이썬 버젼 명}## Ex. python 3.11 버젼, venv 폴더 명으로 가상환경 생성 conda create -n venv python=3.11## 가상환경 진입conda activate venv## 가상환경 종료conda deactivatetypstImage 변환from PIL import Image# 원본 파일 열기img = Image.open(\"image.webp\")# PNG로 저장img.save(\"image.png\", \"PNG\")ERRORRAGReranker  코드from langchain_community.cross_encoders import HuggingFaceCrossEncoderhf_reranker = HuggingFaceCrossEncoder(    model_name=\"BAAI/bge-reranker-v2-m3\")  error 문구Error rendering output item using 'jupyter-ipywidget-renderer'Cannot read properties of undefined (reading 'ipywidgetsKernel')  해결 방법pip install ipywidgets --upgradejupyter nbextension enable --py widgetsnbextension --sys-prefixjupyter nbextension install --py widgetsnbextension --sys-prefixOthers라이브러리 관리  방법1pip freeze &gt; requirements.txtpip install -r requirements.txt  방법2pip install pipreqspipreqs ./ --force# 폴더 내에서 환경이 존재하는 경우pipreqs . --force --ignore \"{가상환경}/Lib\"  방법3# 새로운 라이브러리를 설치 후 requirements.txt 에 적용할 때# Ex. cohere 설치했을경우pip freeze | grep cohere",
      "url": "/2025/07/25/PYTHON.html"
    },
  
    {
      "title": "Jekyll Blog",
      "tags": "Jekyll_Blog",
      "desc": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|",
      "content": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|Settings새로운 환경에서 설정  참고 사이트 : jekyll document  RUBY 설치  참고 사이트 : Ruby** 내 ruby version : 3.2.9  bundler 설치  참고 사이트 : Bundler2-1. gemfile 이 존재할 때bundle install2-2. gemfile 이 없을 때Gemfile 작성source 'https://rubygems.org'gem 'nokogiri'gem 'rack', '~&gt; 2.2.4'gem 'rspec'명령어 입력bundle installERRORRuby와 bundler 호환성 문제  error 코드C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor/error.rb:105:in '&lt;class:Thor&gt;': uninitialized constant DidYouMean::SPELL_CHECKERS (NameError)    DidYouMean::SPELL_CHECKERS.merge!(              ^^^^^^^^^^^^^^^^Did you mean?  DidYouMean::SpellChecker        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor/error.rb:1:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor/base.rb:3:in 'Kernel#require_relative'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor/base.rb:3:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor.rb:2:in 'Kernel#require_relative'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendor/thor/lib/thor.rb:2:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendored_thor.rb:8:in 'Kernel#require_relative'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/vendored_thor.rb:8:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/friendly_errors.rb:3:in 'Kernel#require_relative'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/lib/bundler/friendly_errors.rb:3:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/exe/bundle:29:in 'Kernel#require_relative'        from C:/Ruby34-x64/lib/ruby/gems/3.4.0/gems/bundler-2.1.4/exe/bundle:29:in '&lt;top (required)&gt;'        from C:/Ruby34-x64/bin/bundle:25:in 'Kernel#load'        from C:/Ruby34-x64/bin/bundle:25:in '&lt;main&gt;'  해결 방법  Ruby 버젼을 낮추기  다시 설치과정을 거쳐서 확인Jekyll Build Error  error 코드Invalid date '&lt;%= Time.now.strftime('%Y-%m-%d %H:%M:%S %z') %&gt;': Document '.../0000-00-00-welcome-to-jekyll.markdown.erb' does not have a valid date in the YAML front matter.      해결 방법          GitHub Actions 환경에서 이 에러가 발생한 것이라면, 루트 디렉토리에 있는 _posts/가 아닌 vendor/ 내부에 있는 템플릿 파일이 빌드 과정에 포함되지 않도록 설정해야 함.        # _config.yml 에 아래 작성exclude:- vendor      ",
      "url": "/2025/07/25/Jekyll_Blog.html"
    },
  
    {
      "title": "A/B TEST",
      "tags": "AB_TEST",
      "desc": "A/B TEST - 2024년10월28일  tag : AB_TEST|",
      "content": "A/B TEST - 2024년10월28일  tag : AB_TEST|정의  A/B TEST : 두 가지 이상의 버전을 비교하여 어떤 것이 더 나은 성과를 내는지 판단하는 실험 방법A/B TEST 하는 이유  상관관계로부터 인과관계[ 정확히 말하면 인과관계일 가능성이 높은 것 ]를 찾아내기 위함이다.A/B TEST 절차  목표 설정 : 테스트의 목적과 개선하고자 하는 지표를 명확히 정의  가설 수립 : 어떤 변경이 목표 달성에 도움이 될 것인지 가설을 세우기  테스트 설계 : A안(기존안)과 B안(변경안)을 구체화하기 -&gt; 테스트 기간, 샘플 크기, 분석 방법 등을 결정  테스트 실행 : 사용자를 무작위로 A그룹과 B그룹으로 나누고, 각 그룹에 해당 버전을 노출시키기  데이터 수집 : 설정한 기간 동안 각 그룹의 성과 데이터를 수집  결과 분석 : 통계적 유의성을 검증하여 A안과 B안의 성과 차이를 분석  결론 도출 및 적용 : 분석 결과를 바탕으로 더 나은 버전을 선택 -&gt; 선택한 버전을 전체 사용자에게 적용  지속적 개선 : 테스트 결과를 바탕으로 새로운 가설을 수립하고 추가 테스트를 진행주의해야 할 점      Correlation does not imply causation : 상관관계는 인과관계를 뜻하지 않는다.    - A/B TEST를 통해 인과관계를 알아내려면 두 집단을 나눠야 한다 =&gt; 임의적 할당(random assignment)&gt; EX ] 남성 VS 여성, 이번주 사용자 VS 다음주 사용자- A/B TEST를 통해 찾아낸 결과가 범용성을 지니려면 애초에 실험에 참가한 집단이 모집단을 대표할 수 있어야 한다.            테스트를 많이/자주하면 단기적으로 손해가 발생할 수 있다.    &gt; A/B 테스트 결과는 해당 테스트에만 국한되며, 새로운 테스트마다 새로운 기준선이 필요&gt; 이는 끊임없는 테스트 사이클로 이어질 수 있으며, 장기적인 전략 수립을 방해할 수 있다.            A/B 테스팅의 결과는 계절 변화나 취향 변화 등 시간의 흐름에 따라 바뀔 수 있다.    &gt; EX ] 작년 겨울에 진행한 테스트는 언제까지 유효할까?            사용자 행동의 완전한 이해 부족    &gt; A/B 테스트는 어떤 버전이 더 나은 성과를 보이는지는 알려주지만, 왜 그런지에 대한 깊이 있는 이해를 제공하지 않는다.        참고 사이트",
      "url": "/2024/10/28/AB_test.html"
    }
  
]

[
  
  
    {
      "title": "Anaconda Settings",
      "tags": "Settings, Anaconda",
      "desc": "Anaconda Settings - 2025년09월20일  tag : Settings|Anaconda|",
      "content": "Anaconda Settings - 2025년09월20일  tag : Settings|Anaconda|Anaconda 설치 후 환경 변수 설정  환경 변수 진입  Path 클릭  경로 추가        anaconda3    anaconda3\\Library    anaconda3\\Scripts      ",
      "url": "/2025/09/20/anaconda_settings.html"
    },
  
    {
      "title": "Runpod",
      "tags": "RUNPOD",
      "desc": "Runpod - 2025년07월25일  tag : RUNPOD|",
      "content": "Runpod - 2025년07월25일  tag : RUNPOD|ERRORrunpod에 vscode로 접속 시install terminal quit with output: 프로세스에서 없는 파이프에 쓰려고 했습니다.  해결책 : C:\\Users\\{사용자이름}\\.ssh 접속 후 known_hosts 파일 열어서 전부 삭제OthersRUNPOD files → Local Downloads# powershellscp -r -P {포트번호} `  -i \"C:\\Users\\YourUser\\.ssh\\id_ed25519\" `  \"root@{서버주소}:{원격폴더경로}\" `  \"{로컬 저장 경로}\"",
      "url": "/2025/07/25/RUNPOD.html"
    },
  
    {
      "title": "Python",
      "tags": "PYTHON",
      "desc": "Python - 2025년07월25일  tag : PYTHON|",
      "content": "Python - 2025년07월25일  tag : PYTHON|ERRORRAGReranker  코드from langchain_community.cross_encoders import HuggingFaceCrossEncoderhf_reranker = HuggingFaceCrossEncoder(    model_name=\"BAAI/bge-reranker-v2-m3\")  error 문구Error rendering output item using 'jupyter-ipywidget-renderer'Cannot read properties of undefined (reading 'ipywidgetsKernel')  해결 방법pip install ipywidgets --upgradejupyter nbextension enable --py widgetsnbextension --sys-prefixjupyter nbextension install --py widgetsnbextension --sys-prefixOthers라이브러리 관리  방법1pip freeze &gt; requirements.txtpip install -r requirements.txt  방법2pip install pipreqspipreqs ./ --force# 폴더 내에서 환경이 존재하는 경우pipreqs . --force --ignore \"{가상환경}/Lib\"  방법3# 새로운 라이브러리를 설치 후 requirements.txt 에 적용할 때# Ex. cohere 설치했을경우pip freeze | grep cohere",
      "url": "/2025/07/25/PYTHON.html"
    },
  
    {
      "title": "Jekyll Blog",
      "tags": "Jekyll_Blog",
      "desc": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|",
      "content": "Jekyll Blog - 2025년07월25일  tag : Jekyll_Blog|ERRORJekyll Build Error  error 코드Invalid date '&lt;%= Time.now.strftime('%Y-%m-%d %H:%M:%S %z') %&gt;': Document '.../0000-00-00-welcome-to-jekyll.markdown.erb' does not have a valid date in the YAML front matter.      해결 방법          GitHub Actions 환경에서 이 에러가 발생한 것이라면, 루트 디렉토리에 있는 _posts/가 아닌 vendor/ 내부에 있는 템플릿 파일이 빌드 과정에 포함되지 않도록 설정해야 함.        # _config.yml 에 아래 작성exclude:- vendor      ",
      "url": "/2025/07/25/Jekyll_Blog.html"
    },
  
    {
      "title": "Github - 002",
      "tags": "Github",
      "desc": "Github - 002 - 2024년12월16일  tag : Github|",
      "content": "Github - 002 - 2024년12월16일  tag : Github|Merge Conflict 해결방법  Solve Merge Conflict [ 일반적인 상황에서 사용 ]-&gt; Merge 상황에서 해결  Solve Merge Conflict [ 특수한 상황에서 사용 ]-&gt; rebase 방법으로 해결Branch Models  git flow          가장 전통적이고 많이쓰이는 모델각 단계가 명확히 구분되어 배포주기가 주기적인 서비스에 유리. 하지만 복잡        github flow          브랜치 모델의 단순화.CI 의존성이 높고, pull request가 없으면 실수에 대처가 힘듬      $ git branch feature/{새로운 branch 이름}$ git switch feature/{새로운 branch 이름}$ vi {파일명.확장자} # 여기서 main branch 와 다르게 수정$ git add {파일명.확장자}$ git commit$ git push -u origin feature/refactor-fb # u : 새로운 branch에서 push 할 때 한번만 사용하면 OK# 깃허브 리퍼지스토리에 들어가기# Pull requests에 접속 -&gt; Create pull request# feature/{새로운 branch 이름} 선택# Create pull request 선택 후 title, description 잘 짓기 (+ Assignees(담당자) 선택) -&gt; Create pull request# Merge pull request 선택 -&gt; Confirm merge# 작업이 다 끝났으므로# 왼쪽 위 main 클릭 -&gt; View all branches 클릭 -&gt; feature/{새로운 branch 이름} 삭제# git bash에 돌아와서# feature/{새로운 branch 이름} 삭제$ git branch -D feature/{새로운 branch 이름}# github cloud에 있는 최종 데이터를 로컬에 받기$ git pull origin main  gitlab flow          deploy, issue에 대응을 하기 쉽도록 한 모델      stash  작업중인 변경사항 잠시 미뤄두기 [ 새로운 branch 에서 사용 ]  $ git stash$ git stash list     # stash 목록 보기$ git stash pop {번호} # stash 다시 불러오기 {번호}는 특정한 stash 불러올 때만  undo  변경사항 취소하기  $ git restore {파일명.파일확장자}  Unstaging  Stage의 변경사항(blob) Working Directory로 내리기  $ git add {파일명.파일확장자}$ git reset HEAD {파일명.파일확장자}    # HEAD : 마지막의, 최신의  Edit commit message  직전 commit message 수정하기git add -&gt; commit -&gt;  $ git commit --amend  Revert commit  잘못을 인정하고 특정시점으로 되돌리기git add -&gt; commit 인 상황에서  $ git revert --no-commit HEAD~{되돌리고 싶은 commit 숫자}..$ git status   # 삭제 이력 나와있음$ git commit    # 왜 사용했는지 이유를 적어야 함  Issue  github 프로젝트의 다양한 이슈를 관리하기 위한 기능할 일, 버그, 질문 등을 관리하기 위함Label, 상태 관리 등의 업데이트가 잘 이루어져야 원할한 작업 가능template 존재[ 깃허브 repotory -&gt; settings -&gt; issue template ]Issue Labels      Issue의 상태와 종류, 긴급도 등을 표시하기 위함Milestone : 작성된 Issue가 프로젝트의 어떤 주기에서 해결되어야 하는지를 표기Milestone 작성을 통해 해당 Sprint의 달성률과 남은 Issue 파악이 쉬워짐  Projects  github에서 repo issue 기반의 task managementScrum board와 table의 방식 존재.팀의 Admin만 관리 가능(관리자가 관리하는 것이 맞음!!)commit, pull request 등을 통해 자동으로 움직이도록 관리할 수 있음Wiki  repository에서 README.md 에서 더 자세히 설명할 부분이 있을 경우 작성따로 사이트를 만들지 않더라도 해당 프로젝트에 대한 FAQ, Docs 처리 가능프로젝트 중 문서화가 필요한 모든 것들을 담아놓는 공간Daily Scrum, Sprint Retrospection(Liked, Learned, Lacked), Code Convention, Technical Issuespull request [깃허브 상에서]  명령어 지원close, resolve, fix(복수형, 과거형)ex. resolve #1팀 Project REMOTE 과정[main branch 에서 실행]$ git remote -v    # remote 확인보기$ git remote add upstream {팀 repository 주소}   # 관습적으로 팀 이름은 upstream 이라고 부름$ git fetch upstream main   # FETCH_HEAD 라는 공간에 쌓임$ git merge FETCH_HEAD$ git push origin main해야할 것!  직접 프로젝트를 생성하고 협업하는 과정을 처음부터 끝까지 해보기!",
      "url": "/2024/12/16/Github-002.html"
    },
  
    {
      "title": "Computer Structure",
      "tags": "Computer_Engineering",
      "desc": "Computer Structure - 2024년12월15일  tag : Computer_Engineering|",
      "content": "Computer Structure - 2024년12월15일  tag : Computer_Engineering|컴퓨터 구조  컴퓨터의 네 가지 핵심 부품          CPU : 명령어 해석, 실행 담당하는 장치                  레지스터 : 명령어 처리 전후로 값을 임시 저장하는 장치ALU(산술논리연산장치) : 연산을 수행하는 장치 (계산을 담당하는 회로)제어장치 : 명령어를 해석하고 제어 신호를 내보내는 장치                    메인 메모리 &amp; 캐시 메모리 : 실행 중인 프로그램 저장하는 장치 [전원이 꺼지면 삭제]      보조기억장치 : 보관할 프로그램 저장하는 장치 [전원이 꺼져도 저장 유지]      입출력장치 : 컴퓨터 내외부와 정보를 주고받는 장치        (시스템)버스 : 부품 간 정보를 주고받을 통로명령어  소스 코드 : 사람(개발자)가 이해하기 편한 언어 [ 고급 언어 ]          컴파일 : 소스 코드 전체가 컴파일러에 의해 검사, 목적 코드로 변환인터프리트 : 소스 코드 한 줄씩 인터프리터에 의해 검사, 목적 코드로 변환        명령어와 데이터 : 컴퓨터가 이해하기 편한 언어 [ 저급 언어 ]          기계어어셈블리어        오퍼랜드로 연산 코드를 수행해라.          오퍼랜드(operand) : 명령어를 수행할 대상, 대상(데이터)이 직접 명시되기도 하고, 대상의 위치가 명시되기도 함연산 코드(op-code) : 오퍼랜드로 수행할 동작        유효 주소 : 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치  주소 지정 : 유효 주소를 찾는 방법, CPU마다 차이가 있음          즉시 주소 지정 : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명서, 가장 빠른 주소 지정 + 데이터 크기에 제한      직접 주소 지정 : 오퍼랜드 필드에 유효 주소 명시, 오퍼랜드 필드로 표현 가능한 메모리 주소 크기에 제한      간접 주소 지정 : 오퍼랜드 필드에 유효 주소의 주소 명시, 유효 주소 크기에 제한은 없으나, 속도가 비교적 느림      레지스터 주소 지정 : 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명서, 레지스터 접근은 메모리보다 빠르다!      레지스터 간접 주소 지정 : 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시, 메모리 접근은 한 번      데이터  인코딩 : 문자를 0과 1로 이루어진 문자 코드로 변환  디코딩 : 0과 1로 이루어진 문자 코드를 문자로 변환메인메모리 &amp; 캐시 메모리  RAM(Random Access Memory) : 휘발성 저장장치          DRAM : 시간이 지나면 점차 저장된 데이터가 사라지는 RAMSRAM : 시간이 지나도 저장된 데이터가 사라지지 않는 RAMSDRAM : 클럭과 동기화된 RAMDDRSDRAM : 대역폭을 넓혀 속도를 높인 RAM        ROM(Read Only Memory)          Mask ROM : 가장 기본적인 형태의 ROMPROM : 데이터를 한 번 새길 수 있는 ROMEPROM : 지우고 다시 저장 가능한 PROM플래시 메모리 : EEPROM의 발전된, 저렴한 형태, 반도체 기반의 저장장치        엔디안 : 연속해서 저장해야 하는 바이트를 저장하는 순서          빅 엔디안 : 상위바이트부터 저장하는 방식리틀 엔디안 :하위바이트부터 저장하는 방식        물리 주소 : 실제 메모리의 하드웨서 상의 주소  논리 주소 : CPU와 실행 중인 프로그램이 사용하는 주소  논리 주소와 물리 주소 간의 변환을 담당하는 장치 : MMU(Memory Management Unit)보조기억장치와 입출력장치  하드디스크          플래터 : 하드 디스크 상에서 실질적으로 데이터가 저장되는 부분스핀돌 : 플래터를 회전시키는 부분헤드 : 플래터의 데이터를 읽고 쓰는 부분디스크 암 : 헤드를 옮기는 부분        하드디스크의 데이터 단위          트랙, 섹터, 실린더, 블록        하드 디스크의 지연 시간          탐색 시간, 회전 지연, 전송 시간        플래시 메모리 : 반도체 기반의 저장 장치, 매우 범용성 넓은 저장 장치          NAND 플래시 메모리, NOR 플래시 메모리 존재셀(cell) : 플래시 메모리의 가장 작은 저장 단위      ",
      "url": "/2024/12/15/Computer-Structure.html"
    },
  
    {
      "title": "Github - 001",
      "tags": "Github",
      "desc": "Github - 001 - 2024년12월14일  tag : Github|",
      "content": "Github - 001 - 2024년12월14일  tag : Github|Github  git bash 에서 아래 나오는 코드 실행하기환경설정  정보 확인하기$ git config --list  위 출력에서 없는 것을 확인한 후 추가$ git config --global uesr.name \"{username}\"$ git config --global user.email \"{emaliaddr}\"$ git config --global core.editor \"vim\"$ git config --global core.pager \"cat\"  Tip  만약 core.editor 값이 vim, notepad 두 개가 있을 경우  $ vi ~/.gitconfig    위 명령어 입력 후 notepad부분을 지우고 저장 후 다시 $ git config –list 로 확인하기깃허브 생성  단계          깃허브 접속      create repository -&gt; public 선택, Lisence : MIT 로 선택      주소 복사 후[HTML] git bash 에서 다음 명령어 입력        git clone \"주소\"                    깃허브 상태 확인 후 commit 까지$ git status # 자주 확인해주는 것이 좋다.$ git add {파일명.확장자}$ git commit$ git remote      # origin$ git remote -v$ git push origin main # origin[git remote으로 확인한 값]에 main branch로 올린다.  비밀 키 받기          오른쪽 맨 위 프로필 아이콘 클릭 -&gt; Settings 클릭      왼쪽 사이드 바에서 Developer Settings 클릭      왼쪽 사이드 바에서 Personal access tokens 아래에 있는 Tokens(Classic) 클릭      오른쪽 위에 Generate new token 선택 후 Generate new token(classic) 선택      pre-commit  commit 수행 전 체크해야 할 것들을 자동 수행하도록 도와주는 도구참고 사이트$ pip install pre-commit (or $ pip3 install pre-commit) # 설치$ pre-commit --version # 잘 설치되었는지 확인$ pre-commit sample-config &gt; .pre-commit-config.yaml # .pre-commit-config.yaml 파일 생성$ cat .pre-commit-config.yaml # 내용보기  사용방법          commit 하기 전에 사용      $ pre-commit run$ pre-commit run -a # 이것을 주로 사용하는 것 같다.[개인적인 의견]            Branch  분기점을 생성하여 독립적으로 코드를 변경할 수 있도록 도아주는 모델  branch 확인하기$ git branch$ git branch -r$ git branch -a  branch 생성$ git branch {branch 이름} # branch 생성$ git switch {branch 이름} # branch 전환... { 여기서 branch에서 작업 add -&gt; commit }$ git switch main # main branch 로 전환$ git merge {branch 이름} # main이 아닌 다른 branch 에서 작업한 것을 합치기$ git branch -D {branch 이름} # branch 삭제그 외  보기좋은 로그 출력하기    $ git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"    commit 메세지 작성하는 방법          참고사이트        github repository 생성 사이트          참고사이트        gitignore 파일 만들기          참고사이트1참고사이트2        github에서 jupyter notebook 변경사항을 보고 싶을 때          오른쪽 위 프로필 사진 클릭 -&gt; Feature preview 클릭 -&gt; Rich Jupyter Notebook Diffs 활성화        git 을 쓰면서 습관들이면 안되는 것    &gt; $ git add . : 현재 디렉토리 하위의 모든 파일을 staging할 때 사용.&gt; but, 현재 commit단위에 들어가면 안되는 파일까지 휩쓸릴 수 있으므로 습관적으로 사용하면 안됩니다.&gt; $ git commit -m \"Message\" : 쉘에서 바로 메시지를 쓰면서 커밋할 때 사용.&gt; but, revert commit, merge commit 등의 상황에서 메시지를 덮어쓸 우려가 있으므로 습관적으로 사용하면 안됩니다.&gt; 저장소 안에 저장소 clone 하기 : 프로젝트 단위는 항상 독립적으로 존재해야 합니다.&gt; 의미없는 commit message 남기기(ex. a, 1, ..) : commit message는 제목만으로 해당 작업단위에 대한 설명이 가능해야 나중에 고생하지 않습니다.&gt; Conventional commit 잘 지키기!!      ",
      "url": "/2024/12/14/Github-001.html"
    },
  
    {
      "title": "DataBase System",
      "tags": "Computer_Science",
      "desc": "DataBase System - 2024년12월13일  tag : Computer_Science|",
      "content": "DataBase System - 2024년12월13일  tag : Computer_Science|DataBase  데이터베이스는 데이터를 저장하고 관리하기 위한 체계적인 방법을 제공하는 컴퓨터 시스템Types of database  관계형 데이터베이스(Relational database)          테이블 형태로 데이터를 저장하고 SQL(Structured Query Language)을 사용하여 데이터를 검색하고 조작하는 데이터베이스 유형대규모 데이터를 처리하는데 적합하며, 데이터의 일관성과 무결성을 보장한다.데이터베이스 내의 데이터는 중복을 최소화하여 일관성을 유지하며, 데이터를 업데이트하거나 삭제할 때 다른 테이블 간의 연관성을 유지하여 무결성을 보장Ex. Oracle, MySQL, Microsoft SQL Server        NoSQL 데이터베이스(Not only SQL)          관계형 데이터베이스와는 다른 형태의 데이터 모델을 사용하는 비관계형 데이터베이스 유형대량의 비정형 데이터를 다루는 데에 적합하며, 수평적 확장성을 강조데이터를 컬렉션(collection), 문서(document), 그래프(graph) 등의 형태로 저장수평적 확장이 가능하도록 설계되어 있다.Ex. MongoDB, Cassandra, Couchbase, Redis, Amazon DynamoDB대규모 분산 시스템에서 사용되며, 대량의 비정형 데이터를 저장하고 처리하는 데에 적합        메모리 데이터베이스(In-memory database)          디스크 대신 메모리(RAM)를 사용하여 데이터를 저장하고 처리하는 데이터베이스주로 실시간 데이터 처리나 대규모 데이터 처리 등의 분야에서 사용하지만, 메모리 데이터베이스는 메모리 크기에 제한을 받기 때문에 대용량 데이터 처리에는 적합하지 않다.또한, 메모리에 데이터를 저장하기 때문에 시스템에 장애가 발생하면 데이터가 손실될 가능성이 있다.Ex. Redis, Memcached, Apache Ignites        분산 데이터베이스(Distributed database)          여러 대의 컴퓨터에 데이터를 분산하여 저장하고, 이를 중앙 집중식으로 관리하는 데이터베이스분산 데이터베이스는 대규모 데이터 처리를 위해 설계되어 있으며, 여러 대의 서버를 사용하여 데이터를 처리하므로 단일 서버에 비해 처리량이 향상될 수 있다.분산된 데이터를 병렬적으로 처리할 수 있기 때문에 빠른 데이터 처리 속도를 보장할 수 있다.분산 데이터베이스는 서버 간 통신을 필요로 하므로 네트워크 대역폭의 한계나 네트워크 장애 등이 발생할 경우 데이터 접근 속도가 저하될 수 있다데이터 일관성 등의 문제를 해결하기 위한 추가적인 구현이 필요하다Ex.  Oracle RAC, Apache Cassandra, MongoDB      Database schema design  데이터베이스의 구조를 설계하는 과정스키마 디자인은 데이터베이스의 정확성, 일관성, 유지보수성 등을 결정하는 중요한 요소테이블의 속성(Column)을 적절하게 설계하고, 테이블 간의 관계(Relationship)를 정의하여 데이터를 효율적으로 저장하고 관리할 수 있도록 한다.  ERD(Entity-Relationship Diagram)          개체와 그들 간의 관계를 시각적으로 나타내는 모델링 도구데이터베이스의 구조와 관계를 쉽게 이해할 수 있으며, 효율적인 데이터 저장과 검색이 가능한 스키마를 설계할 수 있다.      유형1. 일대일(One-to-One): 한 테이블의 레코드가 다른 테이블의 레코드와 하나씩 대응하는 관계2. 일대다(One-to-Many): 한 테이블의 레코드가 다른 테이블의 여러 레코드와 대응하는 관계3. 다대다(Many-to-Many): 한 테이블의 레코드가 다른 테이블의 여러 레코드와 대응하고, 다른 테이블의 레코드도 한 테이블의 여러 레코드와 대응하는 관계            ",
      "url": "/2024/12/13/Database_System.html"
    },
  
    {
      "title": "Operating System Concepts",
      "tags": "Computer_Science",
      "desc": "Operating System Concepts - 2024년12월11일  tag : Computer_Science|",
      "content": "Operating System Concepts - 2024년12월11일  tag : Computer_Science|Introduction to Operaing SystemsOperating System 이란?  유저가 컴퓨터를 편하게 사용할 수 있게 모든 하드웨어를 관리해주는 프로그램Operating System 의 구조  Kernel : 프로세스 관리, 메모리 관리, 저장공간 관리, 장치 관리 등 컴퓨터에 속한 자원들에 대한 접근을 중재하는 역할  Interface : 사용자의 명령을 컴퓨터에 전달하고 결과를 사용자에게 알려주는 소통의 역할  System Call : 사용자나 프로그램이 직접적으로 컴퓨터 자원에 접근하는 것을 막고 커널을 보호하기 위해서 만든 코드 집합.  Driver : 프린터, 키보드 및 디스크 드라이브와 같은 하드웨어 장치와 운영체제 간의 통신을 가능하게 하는 소프트웨어  운영체제를 통해 안정적이고, 효율적인 동작을 하기 위해서는 사용자 또는 응용프로그램이 직접 하드웨어에 접근하는 것을 막아야 한다.이 때문에 User Mode(CPU 명령어 사용을 제한)와 Kernel Mode(CPU 명령어를 사용해 하드웨어를 직접 제어)로 분리해 운영체제를 사용User Mode와 Kernel Mode 사이는 System Call and Interrupt을 통해서 전환된다.System calls and APIsSystem Call  입출력, 메모리할당, 프로세스의 생성 등을 수행하는 코드의 집합.  유형          Process Control      File Management      Device Management      Information maintenance      Communications      Overview of popular operating systems (Windows, Linux, macOS)  운영체제는 데스크탑 뿐만 아니라 임베디드, 서버, 모바일 등의 기기에서도 사용됨대표적인 OS의 예시로는 Windows, Unix, macOS, Android 등이 있다.Processes and ThreadsProcess  job이나 task라고도 불리며 PCB(Process Control Block)이라는 걸로 Process들을 관리함Process state and transitions  new : 새롬게 생성된 Process  ready : CPU에서의 실행을 기다리는 상태  running : 실행중인 process  waiting : I/O(사용자의 입출력)이나 scheduling에 의한 대기 상태  terminated : 실행을 마친 상태Process Management  Process Control Block          각각의 process는 Process Control Block(PCB)에 관련된 정보를 저장한다.PCB에서 다루는 Process 정보        Process 생성          parent process에서 child process를 생성process들은 고유한 process identifier(pid)를 통해 구분, 관리 됨생성 시 child process는 부모의 PCB를 공유 받으며 어떤 정보를 공유할지는 공유 옵션에 따라 달라짐      Resource sharing option(Full/Partial/No sharing)Execution option(Overlay/Swapping)Address space option(Fixed/Variable)              Process 제거(termination)          exit system call을 통해 process를 삭제할 수 있다.present process는 wait system call를 통해 child가 정상적으로 제거되었는지 확인이 때 제대로 process가 제거되지 않으면 Zombie/Orphan 상태의 process가 만들어진다.      Zombie process: parent에서 child가 죽은걸 모르고 process table에 child에 대한 정보가 남아있는 경우Orphan: child가 terminate되기 전에 parent가 죽어버려서 부모가 없어진 경우              Process Scheduling          CPU 내부에서 어떤 process를 다음에 실행할지 선택하는 기능```        EX사용자는 동시에 여러 일을 수행하길 원함(웹서핑을 하면서 노래를 듣고, 카톡알림이 울리는 등).하지만 한번에 실행될 수 있는 Process의 수는 정해져 있음(보통 하나, Multi-core 환경에서는 늘어날 수 있음).따라서 Process Scheduling을 통해서 실행하는 Process를 바꿔주면서 여러 프로세스를 동시에 실행하는 것 같은 효과를 냄.```Context switching  Context switching은 Process가 종료되거나 Scheduling에 의해서 종료될 때 발생이전의 process 상태를 저장하고 새로운 프로세스의 PCB를 가져오는 역할Overhead가 심함Threads and multithreading  Thread          flow of control whitin a process(process와 subprocess로 이해할 수 있음)각각의 thread는 각자의 register state와 stack을 가지고 있다.CPU scheduling의 기본 단위      process는 프로세스 간의 전환에 대하여 PCB에 접근해서 Process address space를 복사해오는 등의 과정 때문에 overhead가 클 수 밖에 없는데,Thread는 Process에 비해 creation과 switching에 드는 시간이 적다는 장점이 있다. (Memory와 CPU 효율성 면에서 모두 장점을 가짐)                    Multi-threading          하나의 process에 대해서 여러 thread가 만들어질 수 있고, 이 때 code와 address space, operating resources를 공유한다.멀티쓰레딩을 통해서 동시성을 추구한다.병렬성(parallelism) : 여러 코어에서 동시에 process가 처리될 때 [ = num of CPUs(cores) ]동시성(concurrency) : illusion of parallelism        Multi-processing : 두 개 이상, 다수의 프로세서(처리장치, 프로세스 아님)가 협력적으로 작업을 동시에 처리하는 것Process SchedulingOverview of process scheduling  Process Scheduling을 통해서 CPU 효율성을 최대화할 수 있다.Scheduling은 process의 상태가 바뀔 때 일어나고 처리할 process는 ready queue와 device queue에 저장되어 관리된다.  단일프로세서는 하나의 running process를 가질 수 있기 때문에 더 많은 process가 존재한다면각각은 CPU에서 실행중인 process가 종료되거나 rescheduled 될 때까지 기다려야한다. 이 때 필요할 것이 process scheduling이다.  Scheduling Criteria  효율성을 판단할 때의 기준들          CPU utilization: CPU를 가능한 바쁜상태(일하고 있는 상태)로 유지하는가      Throughput: 일정한 단위 시간 동안 얼마나 많은 수의 프로세스가 완료되었는가      Turnaround time: 특정 프로세스를 실행하는데 걸리는 시간      Waiting time: ready queue에서 기다린 시간      Response time: process가 ready queue에서 기다리고 끝날때까지 걸린 시간.        CPU utilization과 Throughput을 최대화하고, turnaround time과 waiting time, response time을 최소화하는 것이 중요하다.Scheduling algorithms  non-preemptive(비선정형) : Process가 자원을 반납하기 전까지 다른 프로세스가 자원을 사용할 수 없음          수행시간이 긴 프로세스가 자원을 점유하게 되면 이후 실행되어야 하는 프로세스들이 자원을 할당받지 못하는 기아 현상이 발생        preemptive(선정형) : Process가 한번 실행될 때 제한된 시간만을 할당해서 사용          프로세스의 우선 순위에 따라 스케쥴링을 하게 되므로 우선순위가 낮은 프로세스는 기아 상태에 빠짐                  비선점형      선점형                  정해진 시간 없이process 종료 전까지 점유      일정 시간을 process에 할당해 해당 시간만 자원을 사용하고 반납              중간에 interupt가 일어나지 않음      interupt를 통해 실행 중인 process를 교체              종료 후 context switch 외에 추가적인 오버헤드 없음      context switch 가 일정 시간마다 일어나기 때문에 오버헤드 있음              프로세스 우선순위 고려 없음      프로세스에 대한 우선순위를 고려              FCFS, SJF, Priority Scheduling      Round-Robin, Multilevel Queue Scheduling        FCFS(First Come, First Served) Scheduling → 선착순          먼저 도착한 프로세스를 먼저 실행하고, 프로세스가 도착한 순서대로 CPU를 할당한다.보편적으로 프로세스들의 평균 대기 시간이 길어진다는 문제가 있다.        SJF(Shortest Job First) Scheduling          다음에 실행할 프로세스를 선택할 때 실행 시간이 가장 짧을 것으로 예상되는 프로세스를 선택하는 방식.이 경우 FCFS보다 평균 대기 시간이 줄어들지만 CPU burst time이 긴 프로세스의 경우 오히려 대기시간이 증가하고 심할 경우 starvation 상태가 되는 문제점이 있다.        RR(Round-Robin) Scheduling          각 프로세스에 차례로 일정한 시간 할당량(time quantum) 동안 CPU 자원을 차지할 수 있도록 함.time quantum 시간이 길다면 FCFS와 같은 형태로 작동하므로 RR 스케줄링을 사용하는 의미가 줄어들고, 시간이 너무 짧다면 너무 많은 Overhead가 생기기 때문에 좋지 않다.따라서 적절한 time quantum 길이를 찾는 것이 중요함.      Memory ManagementOverview of memory management  Memory : 메인 메모리 RAM(Random Access Memory)을 말하며, 프로그램 실행 시 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간  Address binding 과 MMU          Physical address vs. Logical address      Physical address : 프로세스가 실행되면서 메모리 내부에 실제로 프로세스가 위치해 있는 주소를 의미물리적 주소의 경우 항상 그 주소가 비어있을것이라는 보장이 없고, 이미 메모리에 프로그램이 올라가 있으면 문제가 발생이를 해결하기 위해서 나온 것이 Logical addressLogical address : 가상 주소라고도 하며, 물리적 주소와 논리적 주소를 잘 매핑하는 것이 중요하다.            Address binding : 논리적 주소에 데이터를 저장해둔 뒤 데이터를 메모리에 로딩할 때나 프로세스를 실행할 때 물리적 주소에 직접 매핑하는 방법이러한 매핑은 MMU(Memory Management Unit)에서 수행하며, 보통 물리적 주소가 시작하는 base 주소를 논리적 주소에 더해서 데이터를 메모리에 올린다.Load time binding : 데이터를 메모리에 로딩할 때 논리 주소를 물리 주소에 매핑하는 방식              이 방식은 overhead가 너무 심해 요즘은 잘 사용하지 않고,프로세스를 실행할 때 데이터를 메모리에 올리는 Execution time binding 방식이 주로 쓰인다.            Contiguous memory allocation  logical address 가 연속적이라면 physical address도 연속적으로 배치하는 것을 의미이 경우 MMU가 실행 시간 바인딩에서 해야하는 연산이 적다는 장점이 있다.  또한 Memory Protection의 구현이 쉽다.  Memory Protection : 시스템에서 참고하는 메모리 주소가 참고 가능한 범위를 넘어서는지를 체크하는 것    연속 메모리 할당에서 메모리 공간을 분배하는 방법      Two Partition Allocation : Kernel과 User 모드 두 부분으로 메모리를 분할하여 활동하는 방식메모리 공간이 두 개의 파티션으로 분할되기 때문에, 메모리 공간의 낭비가 발생할 수 있다.    Multiple Partition Allocation      Fixed Size Partition : 메모리 공간을 고정 크기로 나누어 사용하는 메모리 관리 방식&gt; 프로세스가 필요로 하는 메모리 공간의 크기에 따라 파티션을 선택할 수 없기 때문에 내부 단편화가 발생할 가능성이 높음Variable-size Partition : 메모리 공간을 프로세스의 요구에 따라 가변적으로 할당하는 메모리 관리 방식&gt; 내부 단편화 문제를 완화시킬 수 있으나 파티션의 크기가 자주 변하기 때문에 메모리 할당 및 해제 과정이 복잡해지고, 외부 단편화 문제가 발생할 가능성이 높음            연속 메모리 할당 방식에서는 fragmentation(단편화) 의 문제가 발생하게 된다는 큰 문제가 있어 잘 쓰이지 않는다      외부 단편화: 메모리 내에 충분한 크기의 공간이 있더라도 연속적인 공간이 부족하여 메모리 할당이 불가능한 경우내부 단편화: 메모리 공간을 할당할 때, 필요한 공간보다 큰 크기의 공간을 할당하여 할당된 메모리에 사용하지 못하는 부분이 발생하는 경우            File System  컴퓨터에는 다양한 파일들이 저장장치에 저장이 된다.이 떄 운영체제가 저장장치에 있는 데이터를 효율적으로 CRUD 할 수 있는 것을 File System이라 한다.  구성요소          File      Directory      block : 저장 장치의 고정된 데이터 저장 최소 단위      inode : file, Directory의 구조에서 pointer를 이용한 관리를 위한 값      superblock : file system의 중요정보가 담긴 모듬      journaling : 데이터의 무결성을 보장하기 위한 기법        설계시 고려사항          데이터 관리 및 보존      성능 최적화      데이터 무결성      확장성      보안 및 접근 제어      File  File Attribute          Name, Type, Location, Size, TimestampsIdentifier : system이 사용하는 유니크한 값Protection : 접근 권한에 관련된 정보User identification : 생성, 수정자에 대한 정보        File Operation          CRUDReposition : 열여있는 현재 파일의 탐색을 위한 값Truncation : 파일을 자르는 개념Open, Close        Structure of File          Sequential File Structure : 순차적으로 이루어진 파일 구조이며, 불러오는 속도가 빠르며, 작성과 삭제를 하는 구조에서 오래걸리는 단점이 존재Index File Structure : Sequential 구조에 기반을 두고 있지만, 위치를 잡기위한 index가 첨가되어 있다.[DB와 같이 빠른 접근이 필요할 때 적절]Direct File Structure : 불연속 구조를 가지며, 물리적으로 위치를 옮겨가며 파일을 관리.[Hashing 함수를 이용하여 물리적 주소를 접근]        File Descriptor          Open Operation을 통하여 File을 열면 반환이 되는 포인터를 가지는 인덱스 값      Directory  Directory Operation          Create, Delete, SearchList : Directory 내부의 Directory or File을 list화 하여 관리RenameTraverse : 백업과 같이 다른 장치로 이동할 수 있다.        Structure of Directory          Single-Level Directory : 가장 단순한 형태의 구조로 사용자가 여러명일 경우 관리가 힘들다.      Two-Level Directory : 사용자간의 구별을 가지는 형태의 구성      Three-Level Directory : Tree구조라고도 하며 일반적인 컴퓨터에서 통용되는 구조      Acyclic-Graph Directory : Three-Level Directory에서 Link가 추가된 구조, 바로가기와 같은 기능이 추가되었다고 볼 수 있다.      General Graph Directory : 여타 구조들과 다르게 순환이 가능한 구조, 복잡하며 구현이 힘들다.      Allocation of File System  파일 시스템에서 데이터를 저장하게 될 때 할당되는 방식  Contiguous Allocation          디스크에 연속적으로 블록이 할당이 되는 방식 -&gt; 매우 빠른 동작을 하게 된다.하지만 할당 할 수 있는 영역이 부족한 상태에서는 할당하지 못하고 영역이 남는 조각화가 발생할 수 있다.        DisContiguous Allocation          불연속으로 할당을 하는 방식, 비어있는 블록에 데이터를 분산하여 저장하는 방식      Linked Allocation : 각 블록에 다음 블록의 위치를 저장하여 파일을 이어주는 방식[조각화 문제를 해결할 수 있다.]--&gt; 하지만 연결된 마지막 파일을 사용할때 속도가 느려질 수 있다.Index Allocation : 인덱스 블록을 사용하여 모든 파일 블록의 위치를 저장하는 방식            Type of File system  FAT(File Allocation Table)          초기에 사용하던 방식이며 윈도우에서 대부분 호한이 잘 된다.파일을 작은 클러스터로 나누어서 관리하며 최대용량이 작은 편이다.암호화, 압축이 지원되지 않으며, 조각화와 단편화가 발생하기 쉽다.        NTFS(New Technology File System)          FAT의 한계를 개선한 고급 파일 시스템으로, 파일 암호화, 압축, 파일 복구 등 다양한 기능을 지원        EXT(EXtended File system)          리눅스 기반 운영체제에서 사용하는 파일 시스템Journaling : 데이터 변경사항 발생시 로그에 기록 -&gt; 문제가 발생하게 되면 로그를 기반으로 하여 복구를 할 수 있게 지원Journaling 기능을 추가해 데이터 안정성을 강화하였으며, 대용량 파일 및 파티션을 지원        APFS(Apple File System)          Apple의 최신 파일 시스템으로, SSD 최적화, 스냅샷 기능, 파일 및 디렉토리 복제 성능 향상을 지원      ",
      "url": "/2024/12/11/Operating-System-Concepts.html"
    },
  
    {
      "title": "Computer Architecture",
      "tags": "Computer_Science",
      "desc": "Computer Architecture - 2024년12월09일  tag : Computer_Science|",
      "content": "Computer Architecture - 2024년12월09일  tag : Computer_Science|Computer Organization and Architecture  Computer Architecture란?          컴퓨터 시스템의 구조와 구성요소, 그리고 이들 간의 상호작용에 대한 설계와 구현을 다루는 분야      Components of a Computer System  CPU(Central Processing Unit) : 프로그램의 명령어를 해석하고 실행하는 역할을 한다.[산술 논리 연산 장치(ALU), 제어 장치, 레지스터 등으로 구성]  Main Memory : 프로그램이나 데이터를 저장하는 공간으로, CPU가 작업을 수행할 때 필요한 명령어나 데이터가 저장되어 있다.[RAM(Random Access Memory) 존재]  Input Device : 사용자가 컴퓨터에 데이터나 명령을 입력하는 장치[키보드, 마우스]  Output Device : 컴퓨터에서 처리한 결과를 사용자에게 보여주는 장치[모니터, 스피커]  Storage(Secondary Memory) : 데이터를 임시적, 반영구적으로 저장하는 장치[하드 디스크 드라이브, SSD, USB 플래시 드라이브]  Bus : 컴퓨터 내부에서 데이터와 명령어를 전송하는 통로[데이터 버스, 주소 버스, 제어 버스 등]  (Mother)Board : CPU, 메모리, 버스 등의 하드웨어 요소들이 담겨 있는 회로 기판폰 노이만 아키텍쳐(Von Neumann Architecture)  프로그램과 데이터가 같은 메모리 공간에서 저장되어 처리되는 구조구성요소 : CPU, 메모리, 입출력 장치특징 : 명령어와 데이터가 동일한 메모리에 저장되어 있기 때문에, 명령어와 데이터를 구분하기 위한 별도의 제어 신호가 필요하지 않다는 것단점 : 위 특징 때문에 명령어와 데이터를 동시에 처리할 수 없다는 단점을 가짐 -&gt; 현대 컴퓨터에서는 병렬 처리 기술 등을 이용해 이러한 한계를 극복하고 있다.Instruction Cycle  CPU가 메모리부터 1개의 명령어를 가져와 어떤 동작을 요구하는지 결정하고 이를 수행하는 연속적인 과정  과정          Fetch : CPU가 Instruction을 memory로부터 1word를 읽어 다음으로 실행할 명령어를 인출한다.      Decode : CPU가 인출한 명령어를 해독하여 명령어가 어떤 작업을 수행해야 하는지를 결정      Execute : CPU가 결정된 명령어를 실행      Memory(Access) : CPU가 메모리에 접근하여 데이터를 읽거나 쓸 수 있다.      Write Back : 계산된 결과를 레지스터(Register)에 저장한다.      Central Processing UnitCPU는 컴퓨터 시스템의 핵심 요소 중 하나로 프로그램의 명령어를 해석하고 실행하는 역할을 담당한다.따라서, CPU는 모든 컴퓨터 시스템에서 필수적인 구성 요소이며, 컴퓨터의 속도와 성능에 큰 영향을 미친다.CPU는 일반적으로 작은 실리콘 칩에 위치하며, 코어(core)라고 불리는 작은 계산 논리 회로의 집합으로 구성된다.이 코어들은 다양한 명령어를 수행하고, 데이터를 처리하고, 메모리와 입출력 장치와의 통신을 관리한다.최근의 CPU는 여러 개의 코어(physical core)를 가진 멀티코어 프로세서가 일반적이다.멀티코어 CPU는 여러 가지 작업을 병렬로 처리하여 컴퓨터의 처리 속도를 향상시키는 데 도움을 준다.또한, CPU는 클럭 속도라고 불리는 주파수로 측정되는 작업 속도를 가지고 있으며, 이 속도가 높을수록 CPU가 처리할 수 있는 명령어 수가 늘어나고, 컴퓨터의 처리 속도가 빨라진다.Components of CPU  Control Unit(CU) : 프로그램의 명령어를 해석하고, 실행하는 부분  Arithmetic/Logic Unit(ALU) : 수치 연산과 논리 연산을 처리하는 부분  Register : CPU내부에 저장되어 있는 소규모 메모리로, 데이터를 저장하거나 처리하는 데 사용된다.성능 향상을 위한 작업 방법Pipelining ( 단계별 병렬처리 ) -&gt; Sync ( 시간에 동기화되어있다. )  Pipelining : 한 가지 작업을 수행하는 데에 여러 단계의 작업이 필요한 경우, 이 단계들을 연속적으로 실행하여 시간을 단축시키는 기술Parallellism (독립적인 병렬처리) -&gt; Async( 시간에 동기화가 되어있지 않아도 된다 )  Parallellism : 한 번에 여러 작업을 수행하는 것[ EX. 여러 개의 CPU 코어를 사용하여 병렬적으로 작업을 처리하는 것 ]- 두 기술의 차이점1. Pipelining : 하나의 작업을 여러 단계로 분할하여 각 단계를 병렬적으로 처리2. Parallellism : 여러 작업을 동시에 처리하여 실행 시간을 단축Memory Organization and ManagementMemory Hierarchy  컴퓨터에서 데이터와 명령어를 저장하는 계층 구조  Speed = Register &gt; L1 Cache &gt; L2 Cache &gt; L3 Cache &gt; Main »&gt; Secondary(SSD)      memory capacity(저장 용량) = Register &lt; Cache « Main «&lt; Secondary(SSD)    Register : 가장 빠른 속도로 데이터에 접근할 수 있는 기억장치  Cache Memory(L1 &gt; L2 &gt; L3) : CPU와 메인 메모리 사이에 위치하는 기억장치, CPU가 처리할 데이터나 명령어를 미리 가져와 저장하므로, 더 빠른 속도로 접근이 가능  Main Memory(DRAM) : 프로그램이 실행될 때 필요한 데이터나 명령어가 저장되는 주 기억장치  Secondary Memory(=Storage) : HDD나 SSD와 같은 보조기억장치를 말함Types of memory(RAM, ROM, Flash Memory)  RAM(Random Access Memory)          컴퓨터가 작업 중인 데이터와 프로그램을 저장하는 메모리읽기와 쓰기 모두 가능하며, 전원이 꺼지면 내용이 지워진다.        ROM(Read-Only Memory)          주로 컴퓨터의 BIOS(Basic Input/Output System)나 장치 드라이브 등 시스템 소프트웨어를 저장하는 메모리읽기만 가능하며, 내용을 수정할 수 없다.전원이 꺼져도 내용이 지워지지 않는다.        [NAND]Flash Memory          컴퓨터나 디지털 기기에서 많이 사용되는 메모리저장하고 읽기와 쓰기 모두 가능하다.전원이 꺼져도 내용이 지워지지 않으며, 비교적 저렴한 가격과 높은 용량을 제공 [ USB 메모리, SD 카드, SSD(Solid State Drive)등에 사용된다 ]      I/OTypes of I/O Device  Block Device  HDD : 기계쩍인 구조로 이루어진 저장 장치, 자성을 띄는 원형 디스크가 회전하면서 헤드로 데이터를 읽고 쓰는 작업이 이루어진다.  구조      Platter : 여러 개의 자성 디스크가 쌓여 있으며, 고속으로 회전합니다.    Head : 데이터를 사용하기 위한 작은 장치로, Platter 위에서 자기 신호를 감지    Spindle : Platter 가 회전 하는걸 고정 해주는 축    Arm : Platter의 특정 위치로 Head를 옮겨주는 역할    장점 : 비교적 저렴한 가격단점 : 기계의 움직임으로 인하여 데이터 입출력이 비교적 느리며, 충격에 취약하다.  SSD : 반도체 메모리 칩(NAND 플래시 메모리)으로 이루어진 저장 장치  구조      NAND memory : 데이터가 저장되는 비휘발성 메모리    Controller : 데이터를 관리하는 역할을 하는 장치    DRAM : Cache를 지원하여 더 빠른 속도를 지원할 수 있다.    장점 : 빠른 동작 속도, 기계가 아니라서 충격에 강함단점 : NAND 메모리 성능의 한계, 비교적 비싼 가격  Character Device : Data가 단발성으로 발생이 되는 streaming data를 다루는 장치[Ex. Network, Keyboard]Components of I/O System  device controller : 각 I/O 장치마다 존재하며, 데이터 전송을 관리하는 하드웨어  구성요소      I/O port : 장치와 직접적으로 명령어 및 데이터를 주고 받는 부분    register : 데이터, 장치의 상태, 동작의 명령어등을 저장하고 보내는 영역    역할      해당하는 device의 하드웨어적인 동작 제어를 함.    데이터를 주고 받는다.    작업 상태에 따른 interrupt를 CPU에 전달    device driver : 하드웨어와 소프트웨어 간의 인터페이스를 제공하는 소프트웨어  구성요소      I/O control : 운영체제와 하드웨어 장치를 관리    buffering : 데이터를 임시저장하여 반응속도를 높여준다.    Interrupt handler : 발생한 interrupt를 처리할 수 있다.    역할      장치 제어, 데이터 관련 정보를 포멧에 맞게 맞춰 보내준다.    장치 상태를 추적하여 오류 발생 시 운영체제에게 알려준다.    종류      kernel mode driver : 자원을 활용하는 상태    user mode driver : 유저가 사용하는 제한된 상태    port : 컴퓨터와 연결이 되는 지점  Bus : I/O Device 간의 연결 및 Device와 CPU등과 연결을 도와준다.Methods of I/O Data transmission  Pooling Method : 장치가 준비되었을 때 CPU에 신호를 보내 작업을 처리하는 방식  동작 순서    - CPU가 명령어 레지스터에 명령어를 작성하고 자신이 할일을 수행    - controller가 명령어 레지스터에서 명령어를 받아서 수행    - controller가 수행완료 및 특이사항 발생시 interrupt를 유발     - CPU가 interrupt를 처리    - CPU가 controller의 결과물을 받는다.  장단점    - 장점 : 감시체계가 사라져서 리소스의 낭비가 사라졌음    - 단점 : interrupt의 발생이 많아질경우 CPU가 계속 응답해줘야 하기때문에 과부하가 발생할 수 있다.  Interrupt Method : CPU 개입 없이 I/O 장치가 직접 메모리와 데이터를 주고받는 방식  동작 순서    - CPU가 DMA controller에 데이터를 요청    - DMA controller가 I/O에서 memory로 데이터를 전송    - memory로 전송 완료 되면 interrupt를 발생    - CPU가 interrupt와 데이터를 사용  장단점    - 장점 : CPU의 간섭없이 많은 데이터를 송수신 할 수 있다.    - 단점 : DMA controller가 지원이 되어야 하며,  적은 데이터를 사용할때는 번거로울 수 있다.",
      "url": "/2024/12/09/Computer-Architecture.html"
    },
  
    {
      "title": "Data Structure and Algorithms",
      "tags": "Computer_Science",
      "desc": "Data Structure and Algorithms - 2024년12월08일  tag : Computer_Science|",
      "content": "Data Structure and Algorithms - 2024년12월08일  tag : Computer_Science|Introduction to Data StructuresData Structures  데이터를 구성, 저장, 조작하는 방법을 의미함 [ 데이터의 관리 효율성을 조절하기 위한 여러가지 구조에 관한 내용 ]대표적으로 Array, List, Stack, Queue, Tree, Graph 가 있다.Abstract Data Type(=ADT)  프로그래밍을 함에 있어 데이터를 추상화하여 논리적인 구조를 정의한 것  장점          데이터에 대한 정보를 이해하고 저장하는 방식을 결정함으로써 최적의 알고리즘을 개발할 수 있음      프로그래밍을 효율적으로 구현할 수 있도록 도와줌        Abstract          복잡한 데이터나 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것실제 데이터의 형태를 그대로 다루는 것이 아니라 데이터가 가져야하는 명세(specification)를 기반으로 만듬      Time and space complexity  Time complexity : 프로그램이 실행되고, 완료되는데 걸리는 시간          Compile TimeExecution Time [ 주로 이 복잡도 사용 ]        Space complexity : 프로그램이 실행되고, 완료되는데 필요한 메모리          고정 공간 요구량 : 자료구조가 사용하는 고정된 메모리 공간을 의미[Ex. int, double]가변 공간 요구량 : 필요에 따라 동적으로 할당, 해제되는 메모리 공간을 의미[Ex. function call]        Big Oh, Big Ω, and Big Θ notation          Big oh : 최악의 경우Big Ω : 최선의 경우Big Θ : 평균      \\[f(n) = O(g(n)) \\iff \\exists C &gt; 0, n_0 \\in \\mathbb{N} \\text{ such that } \\forall n \\geq n_0, 0 \\leq f(n) \\leq Cg(n)\\]Stacks and QueuesStack  LIFO(Last-In, First-Out) 구조를 가진 자료구조가장 최근에 삽입한 요소를 top이라고 지칭한다.Stack의 구조는 컴퓨터 가상메모리의 Stack 영역에서 사용되는데, 함수가 호출되면서 다시 복귀할 주소를 저장하거나, 지역변수, 매개변수 등을 임시로 저장하는데에 쓰인다.Queues  FIFO(First-In, First-Out) 구조를 가진 자료구조front와 rear로 가장 먼저 들어온 요소와 제일 마지막에 들어온 요소에 접근한다.Enqueue : queue에 원소를 삽입  | Dequeue : queue에서 원소를 삭제Linked List and Hash TableArray  연속된 메모리 공간에 같은 타입의 데이터를 순차적으로 저장하는 자료구조크기가 고정되어 있기 때문에 배열을 생성할 때 크기를 지정해줘야함[ 배열이 가득 차는 경우 새로운 데이터를 추가할 수 없거나 기존 데이터를 삭제해야 함 ]Linked List  생성 후에 자유롭게 원소를 추가/삭제할 수 있는 자료구조가변적인 길이를 가지고 있기 때문에, 새로운 데이터 추가에 대한 제한이 거의 없다는 장점이 있다.Hash Table  데이터의 key를 hash function 을 통해 hash value으로 변환하고, 이 값을 인덱스로 사용하여 데이터를 저장하거나 검색하는 효율적인 자료 구조평균적으로 O(1)의 시간 복잡도로 데이터에 접근할 수 있다.Hash Table의 사용 목적은 정해진 메모리에 여러 원소를 효율적으로 저장하여 indexing 성능을 O(1)에 가깝게 만드는 것Hash function을 통해 hashing을 하게 되면 다른 원소가 같은 index를 가지는 hash collision이 발생  Hash Collision을 해결하기 위한 방법          Separate Chaining                  방법 : 해시 테이블의 각 인덱스에 연결 리스트나 다른 자료 구조를 사용하여 여러 개의 key-value pair를 저장장점 : 간단하고 동적으로 크기를 조절하기 쉽다.                    Open Addressing                  방법 : 충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장                    Trees and Graphs  Tree는 데이터 속 항목을 계층적으로 구조화하는 자료구조  용어          Node : 트리 구조의 교점으로 Node는 데이터(value)를 가지고 있고, 자식노드를 가지고 있다.      Root Node : 트리 구조에서 가장 위에 있는 노드, 즉 시작점이 되는 노드      edge(link) : 트리를 구성하기 위해 노드와 노드를 연결하는 선      level : 트리의 특정 깊이를 가지는 노드의 집합      degree : 각 노드가 지닌 가지의 수를 말하며 ‘차수’라고도 함      Leaf Node(Terminal Node) : 하위에 다른 노드가 연결되어 있지 않은 노드      Internal Node : Leaf노드를 제외한 중간에 위치한 노드들      Depth(=Height) : 트리에 가장 큰 Level의 숫자      Type of TreesBinary Tree  자식 Node가 최대 둘 뿐인 TreeDecision Tree중에 가장 많이 사용되는 CART(Classification and Regression Tree)가 있다.Balanced Tree  어느 한쪽으로 데이터가 치우치지 않도록 균형을 지킬 수 있는 규칙을 가지고 있다.검색용 tree들은 다 검색 효율성을 위해 balanced tree로 정의[Ex. B-tree, B+ tree]Graphs  그래프는 관계를 모델링 하기 위한 자료구조  용어          Vertex(=Node) : Tree에서 Node와 같은 개념      Edge(=link) : 정점과 정점을 있는 선      weight : edge의 가중치 값      degree : Vertex에 연결되어 있는 Edge 수                  out-degree : 방향이 있는 그래프에서 정점에서부터 출발하는 간선의 수in-degree : 방향이 있는 그래프에서 정점으로부터 들어오는 간선의 수                    Path : \\(V_i\\)에서 \\(V_j\\)까지 간선으로 연결된 정점을 순서대로 나열한 리스트                  Ex. A -&gt; E : {A, B, D, E}                    Path length : 경로를 구성하는 간선의 수      Cycle : 경로 중에서 경로의 시작 정점과 마지막 정점이 같은 경로      Undirected Graph  두 정점을 연결하는 간선에 방향이 없는 그래프, 가장 기본적  [ (A, B) == (B, A) ]Directed Graph  간선에 방향이 있어 정해진 방향으로만 이동할 수 있는 그래프 [ &lt;A, B&gt; : A는 출발 정점, B는 도착 정점 ]Weighted Graph  정점을 연결하는 간선에 가중치(Weight)를 할당한 그래프Basic Algorithm Design  Algorithm은 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것  Algorithm은 입력, 출력, 명확성, 유한성, 효율성의 조건을 만족해야 한다.  좋은 Algorithm이란 효율성을 고려한 Algorithm -&gt; 공간복잡도와 시간복잡도를 고려해 알고리즘을 짜야함[‘efficiency’]Sorting Algorithm  주어진 데이터를 정해진 순서대로 재배열하는 알고리즘이다.-&gt; 데이터 간의 비교가 가능해야 함-&gt; 비교를 하려면 기준이 있어야 함-&gt; 기준을 정하려면 계산 방법이 있어야 함Bubble Sort  Time complexity : \\(O(N^2)\\)  인접한 두 원소를 비교하면서 큰 값을 뒤로 보내며 정렬이 이루어짐Selection Sort  Time complexity : \\(O(N^2)\\)  리스트에서 최솟값을 찾아 맨 앞의 요소와 위치를 바꾼다.Insertion Sorting  리스트의 요소를 하나씩 가져와서 이미 정렬된 앞 부분과 비교하여 적절한 위치에 삽입함.Quick Sort  분할 정복(divide and conquer)방법을 통해 리스트를 정렬하는 알고리즘          분할 정복이란? 복잡한 전체의 문제를 부분으로 나누어, 부분적인 문제를 해결하고 다시 합쳐 전체를 해결하는 방식        구현 방식Searching AlgorithmLinear Search(순차 탐색)  Time complexity : \\(O(N)\\)  처음부터 끝까지 순서대로 모든 데이터를 탐색하는 방법Binary Search(이진 탐색)  정렬된 데이터에서 특정 값을 찾을 때 사용하는 방법[Time complexity : \\(O(log_{2}N)\\)]  IF 정렬이 안되어있을 때, 정렬하는데 O(NlogN)시간을 지불하고 사용 가능!정렬이 되어있지 않을 때- Linear Search : m * O(N)- Binary Search : O(NlogN) + m * O(logN)&gt; m &lt; logN 이면, Linear Search를 사용, 그렇지 않으면 Binary Search를 사용",
      "url": "/2024/12/08/Data-Structure-and-Algorithms.html"
    },
  
    {
      "title": "Python Basic - 001",
      "tags": "Python_Basic, Python",
      "desc": "Python Basic - 001 - 2024년11월27일  tag : Python_Basic|Python|",
      "content": "Python Basic - 001 - 2024년11월27일  tag : Python_Basic|Python|인코딩과 디코딩인코딩  인코딩 = 코드화 = 암호화 = 부호화동영상이나 문자 인코딩 뿐만 아니라 사람이 인지할 수 있는 형태의 데이터를 약속된 규칙에 의해 컴퓨터가 사용하는 0과 1로 변환하는 과정python3 는 utf-8이 기본  # -*- coding: utf-8 -*-  # 맨 위에 작성하면 이 코드는 utf-8로 인코딩되어 있는 것  디코딩  디코딩 = 역코드화 = 복호화사람이 이해할 수 있는 언어로 돌려주는 것클로저와 데코레이터클로저(Closure)  함수 안의 함수를 결과로 반환할 때, 그 내부 함수를 클로저라고 한다.사용되는 곳 : 콜백함수, 함수의 순차적 실행, 데코레이터 함수def mul(m):  def wrapper(n):    return m * n  return wrappermul3 = mul(3)print(mul3(10)) # 30데코레이터(Decorator)  함수를 꾸며주는 함수함수를 인수로 받는 클로저@를 이용한 어노테이션으로 사용사용되는 곳 : 반복되는 작업을 여러 함수에 적용할 경우, 기존 함수를 수정하지 않고 추가 기능을 구현하고 싶을 경우def func1(a, b):  val = a + b  return valdef func2(a, b):  val = a * b  return valdef elapsed(func):  def wrapper(a, b):    print(\"함수가 실행됩니다\")    start = time.time()    result = func(a, b)    end = time.time()    print(\"함수 수행시간: %f 초\" % (end - start))    return result  return wrapperdeco1 = elapsed(func1)result = deco1(1,2)print(result)@elapseddef func1(a, b):  val = a + b  return val@elapseddef func2(a, b):  val = a * b  return valIterator와 GeneratorIterator  집합에서 값을 차례대로 꺼낼 수 있는 객체(Object)를 말함한번 반복하면 다시 사용할 수 없다.a = [1,2,3]iterator = iter(a)next(iterator) # 1next(iterator) # 2next(iterator) # 3next(iterator) # ErrorGenerator  iterator를 생성해주는 함수def generator():  yield 'a'  yield 'b'  yield 'c'g = generator()next(g) # 'a'next(g) # 'b'next(g) # 'c'next(g) # errordef client_count(total_client):  n = 1  for num in range(total_client):    print(f'{n}번째 고객님 입장하세요!')    n +=1    yieldmygen = client_count(100)next(mygen) # 1번째 고객님 입장하세요!next(mygen) # 2번째 고객님 입장하세요!next(mygen) # 3번째 고객님 입장하세요!Type Annotation  변수나 상수를 선언할 때, 그 타입을 명시적으로 선언해 줌으로써 어떤 타입의 값이 저장될 것인지를 직접 알려주는 방법사용 시, 코드 가독성과 협업 효율성이 높아짐def add(a: int,b: int) -&gt; int: # a, b는 int형 | 결과값고 int 값이 반환된다는 것을 알려줌  return a + badd.__annotations__ # {'a' : int, 'b' : int, 'return' : int}",
      "url": "/2024/11/27/Python-Basic-001.html"
    },
  
    {
      "title": "Python Regular Expression - 03",
      "tags": "Regular_Expression, Python",
      "desc": "Python Regular Expression - 03 - 2024년11월26일  tag : Regular_Expression|Python|",
      "content": "Python Regular Expression - 03 - 2024년11월26일  tag : Regular_Expression|Python|정규 표현식더 많은 패턴 기능메타 문자 더 보기  | : or 연산자 , Ex. Crow|Servo 는 ‘Crow’나 ‘Servo’와 일치  ^ : 줄의 시작 부분에 일치print(re.search('^From', 'From Here to Eternity')) # &lt;re.Match object; span=(0, 4), match='From'&gt;print(re.search('^From', 'Reciting From Memory')) # None  $ : 줄의 끝부분과 일치하는데, 문자열의 끝이나 줄 바꿈 문자 다음에 오는 모든 위치로 정의print(re.search('}$', '{block}')) # &lt;re.Match object; span=(6, 7), match='}'&gt;print(re.search('}$', '{block} ')) # Noneprint(re.search('}$', '{block}\\n')) # &lt;re.Match object; span=(6, 7), match='}'&gt;  \\A : 문자열의 시작 부분에서만 일치 == ^  \\Z : 문자열 끝부분에서만 일치  \\b : 단어 경계, 단어의 시작이나 끝부분에서만 일치하는 폭이 없는 어서션 &lt;-&gt; \\B : 현재 위치가 단어 경계에 있지 않을 때만 일치p = re.compile(r'\\bclass\\b')print(p.search('no class at all')) # &lt;re.Match object; span=(3, 8), match='class'&gt;print(p.search('the declassified algorithm')) # Noneprint(p.search('one subclass is')) # None그룹  () : 일치하는 텍스트의 시작과 끝 인덱스도 포착p = re.compile('(a(b)c)d')m = p.match('abcd')m.group(0) # 'abcd'm.group(1) # 'abc'm.group(2) # 'b'문자열 수정하기  split() : RE가 일치하는 모든 곳에서 분할하여, 문자열을 리스트로 분할          .split(string, maxsplit=0) : maxsplit 값이 0이 아니면 최대 maxsplit번 분할만 이루어지고, 나머지 문자열은 리스트의 마지막 요소로 반환      p = re.compile(r'\\W+')p.split('This is a test, short and sweet, of split().')# ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', '']p.split('This is a test, short and sweet, of split().', 3)# ['This', 'is', 'a', 'test, short and sweet, of split().']  sub() : RE가 일치하는 모든 부분 문자열을 찾고, 다른 문자열로 대체          .sub(replacement, string, count=0)string 에서 가장 왼쪽에 나타나는 겹쳐지지 않은 RE의 일치를 replacement로 치환count는 치환될 패턴 일치의 최대 수      p = re.compile('(blue|white|red)')p.sub('colour', 'blue socks and red shoes') # 'colour socks and colour shoes'p.sub('colour', 'blue socks and red shoes', count=1) # 'colour socks and red shoes'  subn() : sub()와 같은 일을 하지만, 새로운 문자열과 치환 횟수를 반환p = re.compile('(blue|white|red)')p.subn('colour', 'blue socks and red shoes') # ('colour socks and colour shoes', 2)p.subn('colour', 'no colours at all') # ('no colours at all', 0)",
      "url": "/2024/11/26/Python_Regular_Expression-03.html"
    },
  
    {
      "title": "Python Regular Expression - 02",
      "tags": "Regular_Expression, Python",
      "desc": "Python Regular Expression - 02 - 2024년11월25일  tag : Regular_Expression|Python|",
      "content": "Python Regular Expression - 02 - 2024년11월25일  tag : Regular_Expression|Python|파이썬 정규표현식정규식 사용하기import rep = re.compile('ab*')일치 수행하기match() : 문자열의 시작 부분에서 RE가 일치하는지 판단합니다.p = re.compile('[a-z]+')m = p.match('tempo') # &lt;re.Match object; span=(0, 5), match='tempo'&gt;  group() : RE와 일치하는 문자열을 반환합니다  start() : 일치의 시작 위치를 반환  end() : 일치의 끝 위치를 반환합니다  span() : 일치의(시작, 끝) 위치를 포함하는 튜플을 반환합니다.m.group() # 'tempo'm.start(), m.end() # (0, 5)m.span() # (0, 5)search() : 이 RE가 일치하는 위치를 찾으면서, 문자열을 훑습니다.print(p.match('::: message')) # Nonem = p.search('::: message') # &lt;re.Match object; span=(4, 11), match='message'&gt;m.group() # 'message'm.span() # (4, 11)findall() : RE가 일치하는 모든 부분 문자열을 찾아 리스트로 반환합니다.p = re.compile(r'\\d+')p.findall('12 drummers drumming, 11 pipers piping, 10 lords a-leaping') # ['12', '11', '10']finditer() : RE가 일치하는 모든 부분 문자열을 찾아 이터레이터로 반환합니다.iterator = p.finditer('12 drummers drumming, 11 pipers piping, 10 lords a-leaping')for match in iterator:    print(match.span())# (0, 2)# (22, 24)# (40, 42)컴파일 플래그  그냥 읽어보기            플래그      의미                  ASCII, A      \\w, \\b, \\s 및 \\d와 같은 여러 이스케이프가 해당 속성이 있는 ASCII 문자에만 일치하도록 합니다.              DOTALL, S      .가 개행 문자를 포함한 모든 문자와 일치하도록 합니다.              IGNORECASE, I      대소 문자 구분 없는 일치를 수행합니다.              LOCALE, L      로케일을 고려하는 일치를 수행합니다.              MULTILINE, M      다중 행 일치, ^와 $에 영향을 줍니다.              VERBOSE, X (‘확장’ 용)      더 명확하고 이해하기 쉽게 정리될 수 있는 상세한 RE를 활성화합니다.      ",
      "url": "/2024/11/25/Python_Regular_Expression-02.html"
    },
  
    {
      "title": "Python Regular Expression - 01",
      "tags": "Regular_Expression, Python",
      "desc": "Python Regular Expression - 01 - 2024년11월24일  tag : Regular_Expression|Python|",
      "content": "Python Regular Expression - 01 - 2024년11월24일  tag : Regular_Expression|Python|파이썬 정규표현식  정규식(RE, regexes 또는 regex 패턴)참고 사이트단순한 패턴문자 일치  [ 와 ]          EX. [abc] : a,b 또는 c 문자와 일치 == [a-c]EX. [a-z] : 소문자들만 일치        ^ : 여집합          EX. [^5] : 5를 제외한 모든 문자와 일치        \\ : 백 슬래시 다음에 다양한 특수 시퀀스를 알리는 다양한 문자가 따라올 수 있다.          Ex. [\\] : \\ 일치              \\d : 모든 십진 숫자와 일치 == [0-9]      \\D : 모든 비 숫자 문자와 일치 == [^0-9]      \\s : 모든 공백 문자와 일치 == [ \\t\\n\\r\\f\\v]      \\S : 모든 비 공백 문자와 일치 == [^ \\t\\n\\r\\f\\v]      \\w : 모든 영숫자와 일치 == [a-zA-Z0-9_]      \\W : 모든 비 영숫자와 일치 == [^a-zA-Z0-9_]4.. : “모든 문자”와 일치시키려고 할 때 자주 사용      반복하기  * : 리터럴 문자 ‘*‘와 일치하지 않는다. 대신 이전 문자를 정확히 한 번이 아닌 0번 이상 일치시킬 수 있도록 지정          Ex. [cat] : ‘ct’ (0개의 a문자), ‘cat’(1개의 a문자), ‘caaat’(3개의 a문자) 등과 일치* 은 탐욕적이다 -&gt; RE를 반복할 때, 일치 엔진은 가능한 한 여러 번 반복하려고 시도Ex. [a[bcd]b]이 정규식을 ‘abcbd’와 일치시킨다고 생각                  단계      일치된 것      설명                  1      a      RE의 a가 일치합니다.              2      abcbd      엔진은 가능한 한 길게 [bcd]*와 일치시키려고 문자열의 끝까지 갑니다.              3      실패      엔진은 b를 일치하려고 시도하지만, 현재 위치가 문자열의 끝이므로 실패합니다.              4      abcb      물러서서, [bcd]*가 하나 적은 문자와 일치합니다.              5      실패      b를 다시 시도하지만, 현재 위치는 ‘d’ 인 마지막 문자에 있습니다.              6      abc      다시 물러서서, [bcd]*가 bc하고 만 일치합니다.              6      abcb      b를 다시 시도합니다. 이번에는 현재 위치의 문자가 ‘b’이므로 성공합니다.        + : 하나 이상과 일치  ? : 한 번 또는 0번 일치          Ex. [home-?brew]인 정규표현식은 ‘homebrew’ or ‘home-brew’와 일치        {m, n} : m, n은 십진수 정수, 최소 m번, 최대 n번의 반복이 있어야 함을 의미          [a/{1,3}]인 정규표현식은 ‘a/b’, ‘a//b’, ‘a///b’와 일치{m}인 경우 이전 항목과 정확히 m번 일치      ",
      "url": "/2024/11/24/Python_Regular_Expression-01.html"
    },
  
    {
      "title": "Python Crawling 정리",
      "tags": "Crawling, Python",
      "desc": "Python Crawling 정리 - 2024년11월23일  tag : Crawling|Python|",
      "content": "Python Crawling 정리 - 2024년11월23일  tag : Crawling|Python|크롤링  참고 사이트Library Importimport pandas as pdfrom tqdm import tqdmfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom bs4 import BeautifulSoupfrom urllib.request import Request, urlopenfrom selenium.webdriver.common.keys import KeysDataFrame 정의player_info_cols = ['Name', 'Age', 'Position(s)', 'Foot', 'Height', 'Weight', 'Club', 'Wages']field_player_cols = [    'corners', 'crossing', 'dribbling', 'finishing', 'first-touch', 'free-kick-taking', 'heading', 'long-shots',    'long-throws', 'marking', 'passing', 'penalty-taking', 'tackling', 'technique', 'aggression', 'anticipation', 'bravery',    'composure', 'concentration', 'decisions', 'determination', 'flair', 'leadership', 'off-the-ball', 'positioning',    'teamwork', 'vision', 'work-rate', 'acceleration', 'agility', 'balance', 'jumping-reach', 'natural-fitness', 'pace',    'stamina', 'strength']goalkeeper_cols = [    'aerial-reach', 'command-of-area', 'communication', 'eccentricity', 'first-touch', 'handling', 'kicking',    'one-on-ones', 'passing', 'punching-tendency', 'reflexes', 'rushing-out-tendency', 'throwing','aggression',    'anticipation', 'bravery', 'composure', 'concentration', 'decisions', 'determination', 'flair', 'leadership',    'off-the-ball', 'positioning', 'teamwork', 'vision', 'work-rate', 'acceleration', 'agility', 'balance',    'jumping-reach','natural-fitness', 'pace', 'stamina', 'strength', 'free-kick-taking', 'penalty-taking', 'technique']field_player_df = pd.DataFrame(columns = player_info_cols + field_player_cols)goalkeeper_df = pd.DataFrame(columns = player_info_cols + goalkeeper_cols)   골키퍼와 필드 플레이어는 공통된 player_info를 갖고 있다.단, 스탯 속성은 다르기 때문에 따로 컬럼을 분류하여 만들어야 한다.Crawling 시작# 크롤링 시작options = webdriver.ChromeOptions()options.add_argument(\"--headless\")  # 헤드리스 모드driver = webdriver.Chrome(options=options)driver.get('https://fminside.net/')driver.implicitly_wait(20)driver.find_element(By.XPATH, '//*[@id=\"menu\"]/ul[2]/li[3]/a').click()driver.implicitly_wait(20)  헤드리스 모드를 사용하는 이유 : 광고 팝업창이 자꾸 떠서 다음 창으로 안넘어가는 현상을 막기 위해서 사용for i in tqdm(range(1, 101)): # 100개 데이터만 수집    while True: # Load More Players 버튼 클릭        try:            driver.find_element(By.XPATH, f'//*[@id=\"player_table\"]/div/div[3]/ul[{i}]/li[3]/span[2]/b/a').send_keys(                Keys.CONTROL + Keys.ENTER)            break        except:            driver.find_element(By.XPATH, '//*[@id=\"player_table\"]/div/div[3]/a').click()            driver.implicitly_wait(10)    driver.switch_to.window(driver.window_handles[-1]) # 새 창 전환    driver.implicitly_wait(20)    info_url = driver.current_url # 현재 URL    info_req = Request(info_url, headers={'User-Agent': 'Mozilla/5.0'})    info_html = urlopen(info_req).read()    bs_obj = BeautifulSoup(info_html, 'html.parser')    driver.close()    driver.switch_to.window(driver.window_handles[-1])    pi_data = []    # player_info 공통된 컬럼    player_info_table = bs_obj.select('#player &gt; div:nth-child(2) &gt; ul')    for i in range(1, 7):        pi_data.append(player_info_table[0].select(f'li:nth-child({i}) &gt; span.value')[0].text)    player_contract_table = bs_obj.select('#player &gt; div:nth-child(3) &gt; ul')    pi_data.append(player_contract_table[0].select(f'li:nth-child({1}) &gt; span.value')[0].text)    pi_data.append(player_contract_table[0].select(f'li:nth-child({3}) &gt; span.value')[0].text)    def field_player():        # field_player_info        fp_data = []        player_stats_table = bs_obj.select('#player_stats')[0]        technical_info = player_stats_table.select('div:nth-child(3) &gt; table &gt; tr &gt; td')        for i in range(1, len(technical_info), 2):            fp_data.append(technical_info[i].text)        mental_info = player_stats_table.select('div:nth-child(4) &gt; table &gt; tr &gt; td')        for i in range(1, len(mental_info), 2):            fp_data.append(mental_info[i].text)        physical_info = player_stats_table.select('div:nth-child(5) &gt; table &gt; tr &gt; td')        for i in range(1, len(physical_info), 2):            fp_data.append(physical_info[i].text)        return fp_data    def goalkeeper():        # goalkeeper_info        gk_data = []        player_stats_table = bs_obj.select('#player_stats')[0]        goalkeeping_info = player_stats_table.select('div:nth-child(3) &gt; table &gt; tr &gt; td')        for i in range(1, len(goalkeeping_info), 2):            gk_data.append(goalkeeping_info[i].text)        mental_info = player_stats_table.select('div:nth-child(4) &gt; table &gt; tr &gt; td')        for i in range(1, len(mental_info), 2):            gk_data.append(mental_info[i].text)        physical_info = player_stats_table.select('div:nth-child(5) &gt; table &gt; tr &gt; td')        for i in range(1, len(physical_info), 2):            gk_data.append(physical_info[i].text)        return gk_data    if pi_data[2] == 'GKGK': # 골키퍼인 경우        gk_data = goalkeeper()        goalkeeper_df.loc[len(goalkeeper_df)] = pi_data + gk_data    else:        fp_data = field_player() # 필드 플레이어인 경우        field_player_df.loc[len(field_player_df)] = pi_data + fp_data결과&lt;!DOCTYPE html&gt;                Name  Age  Position(s)  Foot  Height  Weight  Club  Wages  corners  crossing  dribbling  finishing  first-touch  free-kick-taking  heading  long-shots  long-throws  marking  passing  penalty-taking  tackling  technique  aggression  anticipation  bravery  composure  concentration  decisions  determination  flair  leadership  off-the-ball  positioning  teamwork  vision  work-rate  acceleration  agility  balance  jumping-reach  natural-fitness  pace  stamina  strength  0  Kevin De Bruyne  32  MC, MR, ML, AMCMC, AMC  Right  181 CM  68 KG  Manchester City  € 397,800 pw  70  95  80  80  80  85  30  85  35  45  90  75  45  90  60  70  65  70  75  90  85  80  65  75  50  70  99  75  80  65  70  50  80  70  80  65  1  Erling Haaland  22  STST  Left  195 CM  94 KG  Manchester City  € 397,800 pw  35  50  70  90  80  65  75  65  25  30  65  85  35  75  75  95  75  90  75  75  99  80  65  90  35  70  70  65  85  80  85  90  95  95  70  85  2  Kylian Mbappé  24  AMR, AML, STAML, ST  Right  178 CM  73 KG  PSG  € 1,038,960 pw  65  60  90  85  90  55  40  75  15  20  75  90  20  85  30  85  60  85  70  75  90  90  65  85  15  50  75  60  99  80  70  40  75  99  70  55  3  Lionel Messi  36  AMR, AMC, STAMR, AMC, ST  Left  169 CM  67 KG  Inter Miami  € 368,240 pw  75  75  99  85  95  90  50  80  20  20  95  85  35  99  35  80  50  80  65  90  99  99  70  70  25  70  99  45  80  75  90  30  70  75  65  45  4  Harry Kane  29  AMC, STST  Right  188 CM  86 KG  FC Bayern  € 423,280 pw  45  75  70  95  75  55  80  75  30  40  90  99  45  85  55  75  70  90  75  90  95  60  80  85  40  90  95  80  60  60  75  75  80  70  80  75",
      "url": "/2024/11/23/Python_Crawling.html"
    },
  
    {
      "title": "Python Class 정리",
      "tags": "Python, Class",
      "desc": "Python Class 정리 - 2024년11월22일  tag : Python|Class|",
      "content": "Python Class 정리 - 2024년11월22일  tag : Python|Class|객체 지향 프로그래밍(Object Oriented Programming)  프로그램 설계 방법론프로그램을 여러 개의 독립적인 단위인 ‘객체’라는 기본 단위로 나누고‘객체’들의 상호작용을 통해 프로그램을 설계하고 개발하는 방식  장점 : 코드 재사용 용이, 유지보수 용이, 대형 프로젝트 적합  단점 : 실행 속도가 상대적으로 느림, 객체가 많으면 프로그램 용량 커짐, 설계시 많은 시간 소요클래스(Class) &amp; 객체(Object) &amp; 인스턴스  class : 객체 지향 프로그래밍(OOP)에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀(template)이다.object : 클래스에서 정의한 것을 토대로 메모리(실제 저장공간)에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미객체지향 프로그래밍에서 객체는 클래스의 인스턴스이다.메소드(method)  클래스가 가지고 있는 함수를 의미생성자(constructor)  클래스로부터 인스턴스가 생성될 때 자동으로 실행되는 함수상속(inheritance)  새로운 클래스를 만들 때 기존에 있던 클래스의 기능을 물려 받을 수 있는 역할상속 선언  상속 선언을 할 시 자식 클래스에서 부모 클래스의 속성과 메소드는 따로 기재하지 않아도 자동으로 포함메소드 오버라이딩  부모 클래스의 메소드를 자식 클래스에서 재정의 하는 것일반적인 메소드 오버라이딩 : 자식 클래스에서 생성된 객체의 메소드를 부르면 부모 클래스의 메소드는 무시부모 메소드 호출 : 부모 클래스의 메소드도 수행하고 자식 클래스의 메소드도 함께 수행하고 싶을 때 사용코드로 한번에 보는 정리class animal():    def __init__(self, name, voice):        self.name = name        self.voice = voice    def say(self):        print(self.name + \"(이)가 \" + self.voice + \"하고 웁니다\")class cry_01(animal):    def say(self):        print(\"아직 울지 못해요..\")class cry_02(animal):    def say(self):        super().say()        print(\"신기하네요\")cat = animal('고양이', '냐옹')cat.say() # 고양이(이)가 냐옹하고 웁니다baby_cat = cry_01('고양이', '냐옹')baby_cat.say() # 아직 울지 못해요..cat = cry_02('고양이', '먀')cat.say()# 고양이(이)가 먀하고 웁니다# 신기하네요  animal : classobject : catcat은 animal의 인스턴스method : animal class의 say함수생성자 : init상속 선언 : cry_01(animal)일반적인 메소드 오버라이딩 : cry_01 클래스 안에 say함수 재정의부모 메소드 호출 : cry_02 클래스 안에 super().say() 호출",
      "url": "/2024/11/22/Python_Class.html"
    },
  
    {
      "title": "Foundation Model",
      "tags": "Foundation_Model, Blog",
      "desc": "Foundation Model - 2024년11월17일  tag : Foundation_Model|Blog|",
      "content": "Foundation Model - 2024년11월17일  tag : Foundation_Model|Blog|Foundation Model정의      대규모 데이터세트를 기반으로 훈련된 파운데이션 모델(FM)은 데이터 사이언티스트가 기계 학습(ML)에 접근하는 방식을 변화시킨 대규모 딥 러닝 신경망.        데이터 사이언티스트는 처음부터 인공 지능(AI)을 개발하지 않고 파운데이션 모델을 출발점으로 삼아 새로운 애플리케이션을 더 빠르고 비용 효율적으로 지원하는 ML 모델을 개발합니다.        FM이라는 용어는 연구자들이 광범위한 일반화된 데이터와 레이블이 지정되지 않은 데이터에 대해 훈련되고언어 이해, 텍스트 및 이미지 생성, 자연어 대화와 같은 다양한 일반 작업을 수행할 수 있는 ML 모델을 설명하기 위해 만들어졌습니다.  독특한 점적응성일반적으로 감정을 포착하기 위한 텍스트 분석, 이미지 분류, 트렌드 예측과 같은 특정 작업을 수행하는 기존의 ML 모델과는 다른블로그 게시물 작성, 이미지 생성, 수학 문제 해결, 대화 참여, 문서 기반 질문 등 여러 영역에 걸쳐 다양한 작업을 수행할 수 있다.중요한 이유  현재 FM을 처음부터 개발하는 데 수백만 달러의 비용이 들지만 장기적으로는 유용하다.데이터 사이언티스트는 고유한 ML모델을 처음부터 훈련시키는 것보다 사전 훈련된 FM을 사용하여 새로운 ML 애플리케이션을 개발하는 것이 더 빠르고 저렴하다.어떻게 작용하는가?  GAN, 트랜스포머, 변량 인코더 등 복잡한 신경망을 기반으로 한다.FM모델은 자체 지도 학습을 사용하여 입력 데이터에서 레이블을 생성한다.즉, 레이블이 지정된 훈련 데이터 세트로 모델을 가르치거나 훈련시킨 사람은 아무도 없다.무엇을 할 수 있는가?  자연어 처리  시각적 이해  코드 생성  인간 중심의 참여  음성을 텍스트로 변환EX  BERT  GPT  Amazon Titan  AI21 Jurassic  Claude  Cohere  Stable Diffusion  BLOOM  Hugging Face도전과제  도전 과제          인프라 요구 사항      이해력 부족 : 프롬프트의 문맥을 이해하는 데 어려움을 겪는다.      신뢰할 수 없는 답변 : 특정 주제에 대한 질문에 대한 답변은 신뢰할 수 없으며 때로는 부적절하거나 유해하거나 틀릴 수 있다.        참고 사이트",
      "url": "/2024/11/17/Foundation_Model.html"
    },
  
    {
      "title": "A/B TEST",
      "tags": "AB_TEST, Blog",
      "desc": "A/B TEST - 2024년10월28일  tag : AB_TEST|Blog|",
      "content": "A/B TEST - 2024년10월28일  tag : AB_TEST|Blog|정의  A/B TEST : 두 가지 이상의 버전을 비교하여 어떤 것이 더 나은 성과를 내는지 판단하는 실험 방법A/B TEST 하는 이유  상관관계로부터 인과관계[ 정확히 말하면 인과관계일 가능성이 높은 것 ]를 찾아내기 위함이다.A/B TEST 절차  목표 설정 : 테스트의 목적과 개선하고자 하는 지표를 명확히 정의  가설 수립 : 어떤 변경이 목표 달성에 도움이 될 것인지 가설을 세우기  테스트 설계 : A안(기존안)과 B안(변경안)을 구체화하기 -&gt; 테스트 기간, 샘플 크기, 분석 방법 등을 결정  테스트 실행 : 사용자를 무작위로 A그룹과 B그룹으로 나누고, 각 그룹에 해당 버전을 노출시키기  데이터 수집 : 설정한 기간 동안 각 그룹의 성과 데이터를 수집  결과 분석 : 통계적 유의성을 검증하여 A안과 B안의 성과 차이를 분석  결론 도출 및 적용 : 분석 결과를 바탕으로 더 나은 버전을 선택 -&gt; 선택한 버전을 전체 사용자에게 적용  지속적 개선 : 테스트 결과를 바탕으로 새로운 가설을 수립하고 추가 테스트를 진행주의해야 할 점      Correlation does not imply causation : 상관관계는 인과관계를 뜻하지 않는다.    - A/B TEST를 통해 인과관계를 알아내려면 두 집단을 나눠야 한다 =&gt; 임의적 할당(random assignment)&gt; EX ] 남성 VS 여성, 이번주 사용자 VS 다음주 사용자- A/B TEST를 통해 찾아낸 결과가 범용성을 지니려면 애초에 실험에 참가한 집단이 모집단을 대표할 수 있어야 한다.            테스트를 많이/자주하면 단기적으로 손해가 발생할 수 있다.    &gt; A/B 테스트 결과는 해당 테스트에만 국한되며, 새로운 테스트마다 새로운 기준선이 필요&gt; 이는 끊임없는 테스트 사이클로 이어질 수 있으며, 장기적인 전략 수립을 방해할 수 있다.            A/B 테스팅의 결과는 계절 변화나 취향 변화 등 시간의 흐름에 따라 바뀔 수 있다.    &gt; EX ] 작년 겨울에 진행한 테스트는 언제까지 유효할까?            사용자 행동의 완전한 이해 부족    &gt; A/B 테스트는 어떤 버전이 더 나은 성과를 보이는지는 알려주지만, 왜 그런지에 대한 깊이 있는 이해를 제공하지 않는다.        참고 사이트",
      "url": "/2024/10/28/AB_test.html"
    }
  
]

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Operating System Concepts</title>
		<link rel="stylesheet" href="/assets/css/default.css">
		<link rel="stylesheet" href="/assets/css/code.css">
		<link rel="icon" type="image/png" href="/assets/favicon/favicon.ico">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
		<script src="/assets/js/music-controls.js"></script>
		<script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		<!-- head.html 또는 기본 레이아웃 파일에 추가 -->
		<link href='https://cdn.jsdelivr.net/npm/fullcalendar@5.9.0/main.min.css' rel='stylesheet' />
		<script src='https://cdn.jsdelivr.net/npm/fullcalendar@5.9.0/main.min.js'></script>
	</head>
  <body>
      <div class = "header">
  <div class = "blog_image">
    <img src="/assets/images/coffee.png" title="coffee">
  </div>
  <div class = "main_text">
    <h1><a href='/'>In수</a></h1>
  </div>

  <!-- 원하는 위치에 시계를 삽입 -->
  <div id="clock"></div>
</div>

<script>
  function startTime() {
    const today = new Date();
    let h = today.getHours();
    let m = today.getMinutes();
    let s = today.getSeconds();
    m = checkTime(m);
    s = checkTime(s);
    document.getElementById('clock').innerHTML = h + ":" + m + ":" + s;
    setTimeout(startTime, 1000);
  }

  function checkTime(i) {
    if (i < 10) { i = "0" + i };  // 10보다 작으면 앞에 0을 추가
    return i;
  }

  // 페이지 로드 시 시계 시작
  document.addEventListener('DOMContentLoaded', startTime);
</script>

			<div class="container">
			  <div class="navigation">
					<ul>
					  
					    <li><a href="/index.html">HOME</a></li>
					  
					    <li><a href="/posts/index.html">POSTS</a></li>
					  
					    <li><a href="/tags.html">TAGS</a></li>
					  
					    <li><a href="/books.html">BOOKS</a></li>
					  
					    <li><a href="/project.html">PROJECT</a></li>
					  
					</ul>
					<div id="music-controls" style="text-align: center;">
					    <img id="musicGif" src="https://cdn.pixabay.com/animation/2022/12/05/15/23/15-23-06-837_512.gif" alt="Music GIF" style="display: inline-block; width: 50px; height: 50px; margin-top: 21px;">
					    <button id="playButton" onclick="playMusic()" style="font-size: 0.6vw;">Play</button>
					    <button id="pauseButton" onclick="pauseMusic()" style="font-size: 0.6vw;">Pause</button>
					    <button id="nextButton" onclick="nextMusic()" style="font-size: 0.6vw;">Next</button>
					</div>
			  </div>
			  <div class="main">
					<div class="markdown-body">
  <div class="md-content">
    <h1 id="operating-system-concepts---2024년12월11일">Operating System Concepts - 2024년12월11일</h1>

<!-- - tag : Computer_Science  -->
<ul>
  <li>tag : <a href="/tags/tag_Computer_Science.html" class="btn btn-default navbar-btn cursorNorm" role="button">Computer_Science</a>
|</li>
</ul>

<hr />

<h1 id="introduction-to-operaing-systems">Introduction to Operaing Systems</h1>

<h2 id="operating-system-이란">Operating System 이란?</h2>

<blockquote>
  <p>유저가 컴퓨터를 편하게 사용할 수 있게 모든 하드웨어를 관리해주는 프로그램</p>
</blockquote>

<h2 id="operating-system-의-구조">Operating System 의 구조</h2>

<ol>
  <li>Kernel : 프로세스 관리, 메모리 관리, 저장공간 관리, 장치 관리 등 컴퓨터에 속한 자원들에 대한 접근을 중재하는 역할</li>
  <li>Interface : 사용자의 명령을 컴퓨터에 전달하고 결과를 사용자에게 알려주는 소통의 역할</li>
  <li>System Call : 사용자나 프로그램이 직접적으로 컴퓨터 자원에 접근하는 것을 막고 커널을 보호하기 위해서 만든 코드 집합.</li>
  <li>Driver : 프린터, 키보드 및 디스크 드라이브와 같은 하드웨어 장치와 운영체제 간의 통신을 가능하게 하는 소프트웨어</li>
</ol>

<blockquote>
  <p>운영체제를 통해 안정적이고, 효율적인 동작을 하기 위해서는 사용자 또는 응용프로그램이 직접 하드웨어에 접근하는 것을 막아야 한다.<br />
이 때문에 User Mode(CPU 명령어 사용을 제한)와 Kernel Mode(CPU 명령어를 사용해 하드웨어를 직접 제어)로 분리해 운영체제를 사용<br />
User Mode와 Kernel Mode 사이는 System Call and Interrupt을 통해서 전환된다.</p>
</blockquote>

<h2 id="system-calls-and-apis">System calls and APIs</h2>

<h3 id="system-call">System Call</h3>

<blockquote>
  <p>입출력, 메모리할당, 프로세스의 생성 등을 수행하는 코드의 집합.</p>
</blockquote>

<ul>
  <li>유형
    <ol>
      <li>Process Control</li>
      <li>File Management</li>
      <li>Device Management</li>
      <li>Information maintenance</li>
      <li>Communications</li>
    </ol>
  </li>
</ul>

<h2 id="overview-of-popular-operating-systems-windows-linux-macos">Overview of popular operating systems (Windows, Linux, macOS)</h2>

<blockquote>
  <p>운영체제는 데스크탑 뿐만 아니라 임베디드, 서버, 모바일 등의 기기에서도 사용됨<br />
대표적인 OS의 예시로는 Windows, Unix, macOS, Android 등이 있다.</p>
</blockquote>

<h1 id="processes-and-threads">Processes and Threads</h1>

<h2 id="process">Process</h2>

<blockquote>
  <p>job이나 task라고도 불리며 PCB(Process Control Block)이라는 걸로 Process들을 관리함</p>
</blockquote>

<h2 id="process-state-and-transitions">Process state and transitions</h2>

<p><img src="/assets/images/Computer_Science/img_09.png" alt="image_01" style="width: 50vw; height: 20vw" /></p>

<ul>
  <li>new : 새롬게 생성된 Process</li>
  <li>ready : CPU에서의 실행을 기다리는 상태</li>
  <li>running : 실행중인 process</li>
  <li>waiting : I/O(사용자의 입출력)이나 scheduling에 의한 대기 상태</li>
  <li>terminated : 실행을 마친 상태</li>
</ul>

<h2 id="process-management">Process Management</h2>

<ul>
  <li>Process Control Block
    <blockquote>
      <p>각각의 process는 Process Control Block(PCB)에 관련된 정보를 저장한다.<br />
PCB에서 다루는 Process 정보<br />
<img src="/assets/images/Computer_Science/img_10.png" alt="image_02" style="width: 10vw; height: 20vw" /></p>
    </blockquote>
  </li>
  <li>Process 생성
    <blockquote>
      <p>parent process에서 child process를 생성<br />
process들은 고유한 process identifier(pid)를 통해 구분, 관리 됨<br />
생성 시 child process는 부모의 PCB를 공유 받으며 어떤 정보를 공유할지는 공유 옵션에 따라 달라짐</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Resource sharing option(Full/Partial/No sharing)
Execution option(Overlay/Swapping)
Address space option(Fixed/Variable)
</code></pre></div>      </div>
    </blockquote>
  </li>
  <li>Process 제거(termination)
    <blockquote>
      <p>exit system call을 통해 process를 삭제할 수 있다.<br />
present process는 wait system call를 통해 child가 정상적으로 제거되었는지 확인<br />
이 때 제대로 process가 제거되지 않으면 Zombie/Orphan 상태의 process가 만들어진다.</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Zombie process: parent에서 child가 죽은걸 모르고 process table에 child에 대한 정보가 남아있는 경우
Orphan: child가 terminate되기 전에 parent가 죽어버려서 부모가 없어진 경우
</code></pre></div>      </div>
    </blockquote>
  </li>
  <li>Process Scheduling
    <blockquote>
      <p>CPU 내부에서 어떤 process를 다음에 실행할지 선택하는 기능
```</p>
    </blockquote>
  </li>
  <li>EX
사용자는 동시에 여러 일을 수행하길 원함(웹서핑을 하면서 노래를 듣고, 카톡알림이 울리는 등).
하지만 한번에 실행될 수 있는 Process의 수는 정해져 있음(보통 하나, Multi-core 환경에서는 늘어날 수 있음).
따라서 Process Scheduling을 통해서 실행하는 Process를 바꿔주면서 여러 프로세스를 동시에 실행하는 것 같은 효과를 냄.
```</li>
</ul>

<h2 id="context-switching">Context switching</h2>

<blockquote>
  <p>Context switching은 Process가 종료되거나 Scheduling에 의해서 종료될 때 발생<br />
이전의 process 상태를 저장하고 새로운 프로세스의 PCB를 가져오는 역할<br />
Overhead가 심함</p>
</blockquote>

<h2 id="threads-and-multithreading">Threads and multithreading</h2>

<ul>
  <li>Thread
    <blockquote>
      <p>flow of control whitin a process(process와 subprocess로 이해할 수 있음)<br />
각각의 thread는 각자의 register state와 stack을 가지고 있다.<br />
CPU scheduling의 기본 단위</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>process는 프로세스 간의 전환에 대하여 PCB에 접근해서 Process address space를 복사해오는 등의 과정 때문에 overhead가 클 수 밖에 없는데,
Thread는 Process에 비해 creation과 switching에 드는 시간이 적다는 장점이 있다. (Memory와 CPU 효율성 면에서 모두 장점을 가짐)
</code></pre></div>      </div>
      <p><img src="/assets/images/Computer_Science/img_11.png" alt="image_03" style="width: 30vw; height: 20vw" /></p>
    </blockquote>
  </li>
  <li>Multi-threading
    <blockquote>
      <p>하나의 process에 대해서 여러 thread가 만들어질 수 있고, 이 때 code와 address space, operating resources를 공유한다.<br />
멀티쓰레딩을 통해서 동시성을 추구한다.<br />
병렬성(parallelism) : 여러 코어에서 동시에 process가 처리될 때 [ = num of CPUs(cores) ]<br />
동시성(concurrency) : illusion of parallelism</p>
    </blockquote>
  </li>
  <li>Multi-processing : 두 개 이상, 다수의 프로세서(처리장치, 프로세스 아님)가 협력적으로 작업을 동시에 처리하는 것</li>
</ul>

<h1 id="process-scheduling">Process Scheduling</h1>

<h2 id="overview-of-process-scheduling">Overview of process scheduling</h2>
<blockquote>
  <p>Process Scheduling을 통해서 CPU 효율성을 최대화할 수 있다.<br />
Scheduling은 process의 상태가 바뀔 때 일어나고 처리할 process는 ready queue와 device queue에 저장되어 관리된다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>단일프로세서는 하나의 running process를 가질 수 있기 때문에 더 많은 process가 존재한다면
각각은 CPU에서 실행중인 process가 종료되거나 rescheduled 될 때까지 기다려야한다. 이 때 필요할 것이 process scheduling이다.
</code></pre></div>  </div>
</blockquote>

<h2 id="scheduling-criteria">Scheduling Criteria</h2>

<ul>
  <li>효율성을 판단할 때의 기준들
    <ol>
      <li>CPU utilization: CPU를 가능한 바쁜상태(일하고 있는 상태)로 유지하는가</li>
      <li>Throughput: 일정한 단위 시간 동안 얼마나 많은 수의 프로세스가 완료되었는가</li>
      <li>Turnaround time: 특정 프로세스를 실행하는데 걸리는 시간</li>
      <li>Waiting time: ready queue에서 기다린 시간</li>
      <li>Response time: process가 ready queue에서 기다리고 끝날때까지 걸린 시간.</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>CPU utilization과 Throughput을 최대화하고, turnaround time과 waiting time, response time을 최소화하는 것이 중요하다.</p>
</blockquote>

<h2 id="scheduling-algorithms">Scheduling algorithms</h2>

<ul>
  <li>non-preemptive(비선정형) : Process가 자원을 반납하기 전까지 다른 프로세스가 자원을 사용할 수 없음
    <blockquote>
      <p>수행시간이 긴 프로세스가 자원을 점유하게 되면 이후 실행되어야 하는 프로세스들이 자원을 할당받지 못하는 기아 현상이 발생</p>
    </blockquote>
  </li>
  <li>preemptive(선정형) : Process가 한번 실행될 때 제한된 시간만을 할당해서 사용
    <blockquote>
      <p>프로세스의 우선 순위에 따라 스케쥴링을 하게 되므로 우선순위가 낮은 프로세스는 기아 상태에 빠짐</p>
    </blockquote>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>비선점형</th>
      <th>선점형</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>정해진 시간 없이process 종료 전까지 점유</td>
      <td>일정 시간을 process에 할당해 해당 시간만 자원을 사용하고 반납</td>
    </tr>
    <tr>
      <td>중간에 interupt가 일어나지 않음</td>
      <td>interupt를 통해 실행 중인 process를 교체</td>
    </tr>
    <tr>
      <td>종료 후 context switch 외에 추가적인 오버헤드 없음</td>
      <td>context switch 가 일정 시간마다 일어나기 때문에 오버헤드 있음</td>
    </tr>
    <tr>
      <td>프로세스 우선순위 고려 없음</td>
      <td>프로세스에 대한 우선순위를 고려</td>
    </tr>
    <tr>
      <td>FCFS, SJF, Priority Scheduling</td>
      <td>Round-Robin, Multilevel Queue Scheduling</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>FCFS(First Come, First Served) Scheduling → 선착순
    <blockquote>
      <p>먼저 도착한 프로세스를 먼저 실행하고, 프로세스가 도착한 순서대로 CPU를 할당한다.<br />
보편적으로 프로세스들의 평균 대기 시간이 길어진다는 문제가 있다.</p>
    </blockquote>
  </li>
  <li>SJF(Shortest Job First) Scheduling
    <blockquote>
      <p>다음에 실행할 프로세스를 선택할 때 실행 시간이 가장 짧을 것으로 예상되는 프로세스를 선택하는 방식.<br />
이 경우 FCFS보다 평균 대기 시간이 줄어들지만 CPU burst time이 긴 프로세스의 경우 오히려 대기시간이 증가하고 심할 경우 starvation 상태가 되는 문제점이 있다.</p>
    </blockquote>
  </li>
  <li>RR(Round-Robin) Scheduling
    <blockquote>
      <p>각 프로세스에 차례로 일정한 시간 할당량(time quantum) 동안 CPU 자원을 차지할 수 있도록 함.<br />
time quantum 시간이 길다면 FCFS와 같은 형태로 작동하므로 RR 스케줄링을 사용하는 의미가 줄어들고, 시간이 너무 짧다면 너무 많은 Overhead가 생기기 때문에 좋지 않다.<br />
따라서 적절한 time quantum 길이를 찾는 것이 중요함.</p>
    </blockquote>
  </li>
</ol>

<h1 id="memory-management">Memory Management</h1>

<h2 id="overview-of-memory-management">Overview of memory management</h2>

<blockquote>
  <p>Memory : 메인 메모리 RAM(Random Access Memory)을 말하며, 프로그램 실행 시 정보들을 저장하고 가져다 사용할 수 있게 만드는 공간</p>
</blockquote>

<ul>
  <li>Address binding 과 MMU
    <blockquote>
      <p>Physical address vs. Logical address</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Physical address : 프로세스가 실행되면서 메모리 내부에 실제로 프로세스가 위치해 있는 주소를 의미
물리적 주소의 경우 항상 그 주소가 비어있을것이라는 보장이 없고, 이미 메모리에 프로그램이 올라가 있으면 문제가 발생
이를 해결하기 위해서 나온 것이 Logical address
Logical address : 가상 주소라고도 하며, 물리적 주소와 논리적 주소를 잘 매핑하는 것이 중요하다.
</code></pre></div>      </div>
      <p>Address binding : 논리적 주소에 데이터를 저장해둔 뒤 데이터를 메모리에 로딩할 때나 프로세스를 실행할 때 물리적 주소에 직접 매핑하는 방법<br />
이러한 매핑은 MMU(Memory Management Unit)에서 수행하며, 보통 물리적 주소가 시작하는 base 주소를 논리적 주소에 더해서 데이터를 메모리에 올린다.<br />
Load time binding : 데이터를 메모리에 로딩할 때 논리 주소를 물리 주소에 매핑하는 방식</p>
      <blockquote>
        <p>이 방식은 overhead가 너무 심해 요즘은 잘 사용하지 않고,<br />
프로세스를 실행할 때 데이터를 메모리에 올리는 Execution time binding 방식이 주로 쓰인다.</p>
      </blockquote>
    </blockquote>
  </li>
</ul>

<h2 id="contiguous-memory-allocation">Contiguous memory allocation</h2>

<blockquote>
  <p>logical address 가 연속적이라면 physical address도 연속적으로 배치하는 것을 의미<br />
이 경우 MMU가 실행 시간 바인딩에서 해야하는 연산이 적다는 장점이 있다.  <br />
또한 Memory Protection의 구현이 쉽다.</p>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Memory Protection : 시스템에서 참고하는 메모리 주소가 참고 가능한 범위를 넘어서는지를 체크하는 것
</code></pre></div>  </div>
  <p>연속 메모리 할당에서 메모리 공간을 분배하는 방법</p>
  <ol>
    <li>Two Partition Allocation : Kernel과 User 모드 두 부분으로 메모리를 분할하여 활동하는 방식<br />
메모리 공간이 두 개의 파티션으로 분할되기 때문에, 메모리 공간의 낭비가 발생할 수 있다.</li>
    <li>Multiple Partition Allocation
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fixed Size Partition : 메모리 공간을 고정 크기로 나누어 사용하는 메모리 관리 방식
&gt; 프로세스가 필요로 하는 메모리 공간의 크기에 따라 파티션을 선택할 수 없기 때문에 내부 단편화가 발생할 가능성이 높음
Variable-size Partition : 메모리 공간을 프로세스의 요구에 따라 가변적으로 할당하는 메모리 관리 방식
&gt; 내부 단편화 문제를 완화시킬 수 있으나 파티션의 크기가 자주 변하기 때문에 메모리 할당 및 해제 과정이 복잡해지고, 외부 단편화 문제가 발생할 가능성이 높음
</code></pre></div>      </div>
      <p>연속 메모리 할당 방식에서는 fragmentation(단편화) 의 문제가 발생하게 된다는 큰 문제가 있어 잘 쓰이지 않는다</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>외부 단편화: 메모리 내에 충분한 크기의 공간이 있더라도 연속적인 공간이 부족하여 메모리 할당이 불가능한 경우
내부 단편화: 메모리 공간을 할당할 때, 필요한 공간보다 큰 크기의 공간을 할당하여 할당된 메모리에 사용하지 못하는 부분이 발생하는 경우
</code></pre></div>      </div>
    </li>
  </ol>
</blockquote>

<h1 id="file-system">File System</h1>

<blockquote>
  <p>컴퓨터에는 다양한 파일들이 저장장치에 저장이 된다.<br />
이 떄 운영체제가 저장장치에 있는 데이터를 효율적으로 CRUD 할 수 있는 것을 File System이라 한다.</p>
</blockquote>

<ul>
  <li>구성요소
    <ol>
      <li>File</li>
      <li>Directory</li>
      <li>block : 저장 장치의 고정된 데이터 저장 최소 단위</li>
      <li>inode : file, Directory의 구조에서 pointer를 이용한 관리를 위한 값</li>
      <li>superblock : file system의 중요정보가 담긴 모듬</li>
      <li>journaling : 데이터의 무결성을 보장하기 위한 기법</li>
    </ol>
  </li>
  <li>설계시 고려사항
    <ol>
      <li>데이터 관리 및 보존</li>
      <li>성능 최적화</li>
      <li>데이터 무결성</li>
      <li>확장성</li>
      <li>보안 및 접근 제어</li>
    </ol>
  </li>
</ul>

<h2 id="file">File</h2>

<ul>
  <li>File Attribute
    <blockquote>
      <p>Name, Type, Location, Size, Timestamps<br />
Identifier : system이 사용하는 유니크한 값<br />
Protection : 접근 권한에 관련된 정보<br />
User identification : 생성, 수정자에 대한 정보</p>
    </blockquote>
  </li>
  <li>File Operation
    <blockquote>
      <p>CRUD<br />
Reposition : 열여있는 현재 파일의 탐색을 위한 값<br />
Truncation : 파일을 자르는 개념<br />
Open, Close</p>
    </blockquote>
  </li>
  <li>Structure of File
    <blockquote>
      <p>Sequential File Structure : 순차적으로 이루어진 파일 구조이며, 불러오는 속도가 빠르며, 작성과 삭제를 하는 구조에서 오래걸리는 단점이 존재<br />
Index File Structure : Sequential 구조에 기반을 두고 있지만, 위치를 잡기위한 index가 첨가되어 있다.[DB와 같이 빠른 접근이 필요할 때 적절]<br />
Direct File Structure : 불연속 구조를 가지며, 물리적으로 위치를 옮겨가며 파일을 관리.[Hashing 함수를 이용하여 물리적 주소를 접근]</p>
    </blockquote>
  </li>
  <li>File Descriptor
    <blockquote>
      <p>Open Operation을 통하여 File을 열면 반환이 되는 포인터를 가지는 인덱스 값</p>
    </blockquote>
  </li>
</ul>

<h2 id="directory">Directory</h2>

<ul>
  <li>Directory Operation
    <blockquote>
      <p>Create, Delete, Search<br />
List : Directory 내부의 Directory or File을 list화 하여 관리<br />
Rename<br />
Traverse : 백업과 같이 다른 장치로 이동할 수 있다.</p>
    </blockquote>
  </li>
  <li>Structure of Directory
    <ol>
      <li>Single-Level Directory : 가장 단순한 형태의 구조로 사용자가 여러명일 경우 관리가 힘들다.</li>
      <li>Two-Level Directory : 사용자간의 구별을 가지는 형태의 구성</li>
      <li>Three-Level Directory : Tree구조라고도 하며 일반적인 컴퓨터에서 통용되는 구조</li>
      <li>Acyclic-Graph Directory : Three-Level Directory에서 Link가 추가된 구조, 바로가기와 같은 기능이 추가되었다고 볼 수 있다.</li>
      <li>General Graph Directory : 여타 구조들과 다르게 순환이 가능한 구조, 복잡하며 구현이 힘들다.</li>
    </ol>
  </li>
</ul>

<h2 id="allocation-of-file-system">Allocation of File System</h2>

<blockquote>
  <p>파일 시스템에서 데이터를 저장하게 될 때 할당되는 방식</p>
</blockquote>

<ol>
  <li>Contiguous Allocation
    <blockquote>
      <p>디스크에 연속적으로 블록이 할당이 되는 방식 -&gt; 매우 빠른 동작을 하게 된다.<br />
하지만 할당 할 수 있는 영역이 부족한 상태에서는 할당하지 못하고 영역이 남는 조각화가 발생할 수 있다.</p>
    </blockquote>
  </li>
  <li>DisContiguous Allocation
    <blockquote>
      <p>불연속으로 할당을 하는 방식, 비어있는 블록에 데이터를 분산하여 저장하는 방식</p>
      <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Linked Allocation : 각 블록에 다음 블록의 위치를 저장하여 파일을 이어주는 방식[조각화 문제를 해결할 수 있다.]
--&gt; 하지만 연결된 마지막 파일을 사용할때 속도가 느려질 수 있다.
Index Allocation : 인덱스 블록을 사용하여 모든 파일 블록의 위치를 저장하는 방식
</code></pre></div>      </div>
    </blockquote>
  </li>
</ol>

<h2 id="type-of-file-system">Type of File system</h2>

<ol>
  <li>FAT(File Allocation Table)
    <blockquote>
      <p>초기에 사용하던 방식이며 윈도우에서 대부분 호한이 잘 된다.<br />
파일을 작은 클러스터로 나누어서 관리하며 최대용량이 작은 편이다.<br />
암호화, 압축이 지원되지 않으며, 조각화와 단편화가 발생하기 쉽다.</p>
    </blockquote>
  </li>
  <li>NTFS(New Technology File System)
    <blockquote>
      <p>FAT의 한계를 개선한 고급 파일 시스템으로, 파일 암호화, 압축, 파일 복구 등 다양한 기능을 지원</p>
    </blockquote>
  </li>
  <li>EXT(EXtended File system)
    <blockquote>
      <p>리눅스 기반 운영체제에서 사용하는 파일 시스템<br />
Journaling : 데이터 변경사항 발생시 로그에 기록 -&gt; 문제가 발생하게 되면 로그를 기반으로 하여 복구를 할 수 있게 지원<br />
Journaling 기능을 추가해 데이터 안정성을 강화하였으며, 대용량 파일 및 파티션을 지원</p>
    </blockquote>
  </li>
  <li>APFS(Apple File System)
    <blockquote>
      <p>Apple의 최신 파일 시스템으로, SSD 최적화, 스냅샷 기능, 파일 및 디렉토리 복제 성능 향상을 지원</p>
    </blockquote>
  </li>
</ol>

  </div>
  <div class="md-index">
    <h2>목차</h2>
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h1"><a href="#operating-system-concepts---2024년12월11일">Operating System Concepts - 2024년12월11일</a></li>
<li class="toc-entry toc-h1"><a href="#introduction-to-operaing-systems">Introduction to Operaing Systems</a>
<ul>
<li class="toc-entry toc-h2"><a href="#operating-system-이란">Operating System 이란?</a></li>
<li class="toc-entry toc-h2"><a href="#operating-system-의-구조">Operating System 의 구조</a></li>
<li class="toc-entry toc-h2"><a href="#system-calls-and-apis">System calls and APIs</a>
<ul>
<li class="toc-entry toc-h3"><a href="#system-call">System Call</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#overview-of-popular-operating-systems-windows-linux-macos">Overview of popular operating systems (Windows, Linux, macOS)</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#processes-and-threads">Processes and Threads</a>
<ul>
<li class="toc-entry toc-h2"><a href="#process">Process</a></li>
<li class="toc-entry toc-h2"><a href="#process-state-and-transitions">Process state and transitions</a></li>
<li class="toc-entry toc-h2"><a href="#process-management">Process Management</a></li>
<li class="toc-entry toc-h2"><a href="#context-switching">Context switching</a></li>
<li class="toc-entry toc-h2"><a href="#threads-and-multithreading">Threads and multithreading</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#process-scheduling">Process Scheduling</a>
<ul>
<li class="toc-entry toc-h2"><a href="#overview-of-process-scheduling">Overview of process scheduling</a></li>
<li class="toc-entry toc-h2"><a href="#scheduling-criteria">Scheduling Criteria</a></li>
<li class="toc-entry toc-h2"><a href="#scheduling-algorithms">Scheduling algorithms</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#memory-management">Memory Management</a>
<ul>
<li class="toc-entry toc-h2"><a href="#overview-of-memory-management">Overview of memory management</a></li>
<li class="toc-entry toc-h2"><a href="#contiguous-memory-allocation">Contiguous memory allocation</a></li>
</ul>
</li>
<li class="toc-entry toc-h1"><a href="#file-system">File System</a>
<ul>
<li class="toc-entry toc-h2"><a href="#file">File</a></li>
<li class="toc-entry toc-h2"><a href="#directory">Directory</a></li>
<li class="toc-entry toc-h2"><a href="#allocation-of-file-system">Allocation of File System</a></li>
<li class="toc-entry toc-h2"><a href="#type-of-file-system">Type of File system</a></li>
</ul>
</li>
</ul>
    <hr>
    <h2>관련 POST</h2>
    
      
        
      
    
      
        
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
          <p>
            <a href="/2024/12/13/Database_System.html">DataBase System [ 2024년12월13일 ]</a>
          </p>
        
      
    
      
        
      
        
      
    
      
        
          <p>
            <a href="/2024/12/11/Operating-System-Concepts.html">Operating System Concepts [ 2024년12월11일 ]</a>
          </p>
        
      
    
      
        
      
        
      
    
      
        
          <p>
            <a href="/2024/12/09/Computer-Architecture.html">Computer Architecture [ 2024년12월09일 ]</a>
          </p>
        
      
    
      
        
          <p>
            <a href="/2024/12/08/Data-Structure-and-Algorithms.html">Data Structure and Algorithms [ 2024년12월08일 ]</a>
          </p>
        
      
    
      
        
          <p>
            <a href="/2024/12/07/Introduction-to-Computer-Science.html">Introdiction to Computer Science [ 2024년12월07일 ]</a>
          </p>
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
    
      
        
      
        
      
        
      
        
      
    
      
        
      
        
      
        
      
    
      
        
      
        
      
    
  </div>
</div>

<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 56,
  backgroundColor: 'rgb(135, 206, 250)',
  textColor: '#fff'
})</script>

<!-- Latex -->
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

			  </div>
			</div>
			<div class="footer">
  <p>Email : qkrdlstn9701@naver.com</p>
  <a href="https://github.com/insu97">SITE : GITHUB_PAGE</a>
</div>

  </body>
</html>
